var u0=Object.create;var{getPrototypeOf:s0,defineProperty:X0,getOwnPropertyNames:B0,getOwnPropertyDescriptor:c0}=Object,k0=Object.prototype.hasOwnProperty;var h1=(X,q,Q)=>{Q=X!=null?u0(s0(X)):{};const Y=q||!X||!X.__esModule?X0(Q,"default",{value:X,enumerable:!0}):Q;for(let Z of B0(X))if(!k0.call(Y,Z))X0(Y,Z,{get:()=>X[Z],enumerable:!0});return Y},N0=new WeakMap,b1=(X)=>{var q=N0.get(X),Q;if(q)return q;if(q=X0({},"__esModule",{value:!0}),X&&typeof X==="object"||typeof X==="function")B0(X).map((Y)=>!k0.call(q,Y)&&X0(q,Y,{get:()=>X[Y],enumerable:!(Q=c0(X,Y))||Q.enumerable}));return N0.set(X,q),q},F1=(X,q)=>()=>(q||X((q={exports:{}}).exports,q),q.exports);var m0=(X,q)=>{for(var Q in q)X0(X,Q,{get:q[Q],enumerable:!0,configurable:!0,set:(Y)=>q[Q]=()=>Y})};var r0=(X,q)=>()=>(X&&(q=X(X=0)),q);var n0=((X)=>typeof require!=="undefined"?require:typeof Proxy!=="undefined"?new Proxy(X,{get:(q,Q)=>(typeof require!=="undefined"?require:q)[Q]}):X)(function(X){if(typeof require!=="undefined")return require.apply(this,arguments);throw Error('Dynamic require of "'+X+'" is not supported')});var C0={};m0(C0,{resolveObject:()=>D0,resolve:()=>A0,parse:()=>a,format:()=>I0,default:()=>Z1,Url:()=>s,URLSearchParams:()=>$0,URL:()=>L0});function W0(X){return typeof X=="string"}function O0(X){return typeof X=="object"&&X!==null}function Y0(X){return X===null}function o0(X){return X==null}function s(){this.protocol=null,this.slashes=null,this.auth=null,this.host=null,this.port=null,this.hostname=null,this.hash=null,this.search=null,this.query=null,this.pathname=null,this.path=null,this.href=null}function a(X,q,Q){if(X&&O0(X)&&X instanceof s)return X;var Y=new s;return Y.parse(X,q,Q),Y}function I0(X){return W0(X)&&(X=a(X)),X instanceof s?X.format():s.prototype.format.call(X)}function A0(X,q){return a(X,!1,!0).resolve(q)}function D0(X,q){return X?a(X,!1,!0).resolveObject(q):q}var L0,$0,i0,t0,a0,e0,q1,G0,E0,H0,Q1=255,j0,X1,Y1,V0,t,T0,Z1;var M0=r0(()=>{({URL:L0,URLSearchParams:$0}=globalThis),i0=/^([a-z0-9.+-]+:)/i,t0=/:[0-9]*$/,a0=/^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,e0=["<",">",'"',"`"," ","\r",`
`,"	"],q1=["{","}","|","\\","^","`"].concat(e0),G0=["'"].concat(q1),E0=["%","/","?",";","#"].concat(G0),H0=["/","?","#"],j0=/^[+a-z0-9A-Z_-]{0,63}$/,X1=/^([+a-z0-9A-Z_-]{0,63})(.*)$/,Y1={javascript:!0,"javascript:":!0},V0={javascript:!0,"javascript:":!0},t={http:!0,https:!0,ftp:!0,gopher:!0,file:!0,"http:":!0,"https:":!0,"ftp:":!0,"gopher:":!0,"file:":!0},T0={parse(X){var q=decodeURIComponent;return(X+"").replace(/\+/g," ").split("&").filter(Boolean).reduce(function(Q,Y,Z){var U=Y.split("="),J=q(U[0]||""),K=q(U[1]||""),G=Q[J];return Q[J]=G===void 0?K:[].concat(G,K),Q},{})},stringify(X){var q=encodeURIComponent;return Object.keys(X||{}).reduce(function(Q,Y){return[].concat(X[Y]).forEach(function(Z){Q.push(q(Y)+"="+q(Z))}),Q},[]).join("&").replace(/\s/g,"+")}};s.prototype.parse=function(X,q,Q){if(!W0(X))throw new TypeError("Parameter 'url' must be a string, not "+typeof X);var Y=X.indexOf("?"),Z=Y!==-1&&Y<X.indexOf("#")?"?":"#",U=X.split(Z),J=/\\/g;U[0]=U[0].replace(J,"/"),X=U.join(Z);var K=X;if(K=K.trim(),!Q&&X.split("#").length===1){var G=a0.exec(K);if(G)return this.path=K,this.href=K,this.pathname=G[1],G[2]?(this.search=G[2],q?this.query=T0.parse(this.search.substr(1)):this.query=this.search.substr(1)):q&&(this.search="",this.query={}),this}var R=i0.exec(K);if(R){R=R[0];var V=R.toLowerCase();this.protocol=V,K=K.substr(R.length)}if(Q||R||K.match(/^\/\/[^@\/]+@[^@\/]+/)){var E=K.substr(0,2)==="//";E&&!(R&&V0[R])&&(K=K.substr(2),this.slashes=!0)}if(!V0[R]&&(E||R&&!t[R])){for(var W=-1,L=0;L<H0.length;L++){var M=K.indexOf(H0[L]);M!==-1&&(W===-1||M<W)&&(W=M)}var F,z;W===-1?z=K.lastIndexOf("@"):z=K.lastIndexOf("@",W),z!==-1&&(F=K.slice(0,z),K=K.slice(z+1),this.auth=decodeURIComponent(F)),W=-1;for(var L=0;L<E0.length;L++){var M=K.indexOf(E0[L]);M!==-1&&(W===-1||M<W)&&(W=M)}W===-1&&(W=K.length),this.host=K.slice(0,W),K=K.slice(W),this.parseHost(),this.hostname=this.hostname||"";var g=this.hostname[0]==="["&&this.hostname[this.hostname.length-1]==="]";if(!g)for(var T=this.hostname.split(/\./),L=0,B=T.length;L<B;L++){var I=T[L];if(!!I&&!I.match(j0)){for(var A="",D=0,h=I.length;D<h;D++)I.charCodeAt(D)>127?A+="x":A+=I[D];if(!A.match(j0)){var b=T.slice(0,L),x=T.slice(L+1),r=I.match(X1);r&&(b.push(r[1]),x.unshift(r[2])),x.length&&(K="/"+x.join(".")+K),this.hostname=b.join(".");break}}}this.hostname.length>Q1?this.hostname="":this.hostname=this.hostname.toLowerCase(),g||(this.hostname=new L0(`https://${this.hostname}`).hostname);var N=this.port?":"+this.port:"",H=this.hostname||"";this.host=H+N,this.href+=this.host,g&&(this.hostname=this.hostname.substr(1,this.hostname.length-2),K[0]!=="/"&&(K="/"+K))}if(!Y1[V])for(var L=0,B=G0.length;L<B;L++){var k=G0[L];if(K.indexOf(k)!==-1){var j=encodeURIComponent(k);j===k&&(j=escape(k)),K=K.split(k).join(j)}}var $=K.indexOf("#");$!==-1&&(this.hash=K.substr($),K=K.slice(0,$));var O=K.indexOf("?");if(O!==-1?(this.search=K.substr(O),this.query=K.substr(O+1),q&&(this.query=T0.parse(this.query)),K=K.slice(0,O)):q&&(this.search="",this.query={}),K&&(this.pathname=K),t[V]&&this.hostname&&!this.pathname&&(this.pathname="/"),this.pathname||this.search){var N=this.pathname||"",_=this.search||"";this.path=N+_}return this.href=this.format(),this};s.prototype.format=function(){var X=this.auth||"";X&&(X=encodeURIComponent(X),X=X.replace(/%3A/i,":"),X+="@");var q=this.protocol||"",Q=this.pathname||"",Y=this.hash||"",Z=!1,U="";this.host?Z=X+this.host:this.hostname&&(Z=X+(this.hostname.indexOf(":")===-1?this.hostname:"["+this.hostname+"]"),this.port&&(Z+=":"+this.port)),this.query&&O0(this.query)&&Object.keys(this.query).length&&(U=T0.stringify(this.query));var J=this.search||U&&"?"+U||"";return q&&q.substr(-1)!==":"&&(q+=":"),this.slashes||(!q||t[q])&&Z!==!1?(Z="//"+(Z||""),Q&&Q.charAt(0)!=="/"&&(Q="/"+Q)):Z||(Z=""),Y&&Y.charAt(0)!=="#"&&(Y="#"+Y),J&&J.charAt(0)!=="?"&&(J="?"+J),Q=Q.replace(/[?#]/g,function(K){return encodeURIComponent(K)}),J=J.replace("#","%23"),q+Z+Q+J+Y};s.prototype.resolve=function(X){return this.resolveObject(a(X,!1,!0)).format()};s.prototype.resolveObject=function(X){if(W0(X)){var q=new s;q.parse(X,!1,!0),X=q}for(var Q=new s,Y=Object.keys(this),Z=0;Z<Y.length;Z++){var U=Y[Z];Q[U]=this[U]}if(Q.hash=X.hash,X.href==="")return Q.href=Q.format(),Q;if(X.slashes&&!X.protocol){for(var J=Object.keys(X),K=0;K<J.length;K++){var G=J[K];G!=="protocol"&&(Q[G]=X[G])}return t[Q.protocol]&&Q.hostname&&!Q.pathname&&(Q.path=Q.pathname="/"),Q.href=Q.format(),Q}if(X.protocol&&X.protocol!==Q.protocol){if(!t[X.protocol]){for(var R=Object.keys(X),V=0;V<R.length;V++){var E=R[V];Q[E]=X[E]}return Q.href=Q.format(),Q}if(Q.protocol=X.protocol,!X.host&&!V0[X.protocol]){for(var B=(X.pathname||"").split("/");B.length&&!(X.host=B.shift()););X.host||(X.host=""),X.hostname||(X.hostname=""),B[0]!==""&&B.unshift(""),B.length<2&&B.unshift(""),Q.pathname=B.join("/")}else Q.pathname=X.pathname;if(Q.search=X.search,Q.query=X.query,Q.host=X.host||"",Q.auth=X.auth,Q.hostname=X.hostname||X.host,Q.port=X.port,Q.pathname||Q.search){var W=Q.pathname||"",L=Q.search||"";Q.path=W+L}return Q.slashes=Q.slashes||X.slashes,Q.href=Q.format(),Q}var M=Q.pathname&&Q.pathname.charAt(0)==="/",F=X.host||X.pathname&&X.pathname.charAt(0)==="/",z=F||M||Q.host&&X.pathname,g=z,T=Q.pathname&&Q.pathname.split("/")||[],B=X.pathname&&X.pathname.split("/")||[],I=Q.protocol&&!t[Q.protocol];if(I&&(Q.hostname="",Q.port=null,Q.host&&(T[0]===""?T[0]=Q.host:T.unshift(Q.host)),Q.host="",X.protocol&&(X.hostname=null,X.port=null,X.host&&(B[0]===""?B[0]=X.host:B.unshift(X.host)),X.host=null),z=z&&(B[0]===""||T[0]==="")),F)Q.host=X.host||X.host===""?X.host:Q.host,Q.hostname=X.hostname||X.hostname===""?X.hostname:Q.hostname,Q.search=X.search,Q.query=X.query,T=B;else if(B.length)T||(T=[]),T.pop(),T=T.concat(B),Q.search=X.search,Q.query=X.query;else if(!o0(X.search)){if(I){Q.hostname=Q.host=T.shift();var A=Q.host&&Q.host.indexOf("@")>0?Q.host.split("@"):!1;A&&(Q.auth=A.shift(),Q.host=Q.hostname=A.shift())}return Q.search=X.search,Q.query=X.query,(!Y0(Q.pathname)||!Y0(Q.search))&&(Q.path=(Q.pathname?Q.pathname:"")+(Q.search?Q.search:"")),Q.href=Q.format(),Q}if(!T.length)return Q.pathname=null,Q.search?Q.path="/"+Q.search:Q.path=null,Q.href=Q.format(),Q;for(var D=T.slice(-1)[0],h=(Q.host||X.host||T.length>1)&&(D==="."||D==="..")||D==="",b=0,x=T.length;x>=0;x--)D=T[x],D==="."?T.splice(x,1):D===".."?(T.splice(x,1),b++):b&&(T.splice(x,1),b--);if(!z&&!g)for(;b--;b)T.unshift("..");z&&T[0]!==""&&(!T[0]||T[0].charAt(0)!=="/")&&T.unshift(""),h&&T.join("/").substr(-1)!=="/"&&T.push("");var r=T[0]===""||T[0]&&T[0].charAt(0)==="/";if(I){Q.hostname=Q.host=r?"":T.length?T.shift():"";var A=Q.host&&Q.host.indexOf("@")>0?Q.host.split("@"):!1;A&&(Q.auth=A.shift(),Q.host=Q.hostname=A.shift())}return z=z||Q.host&&T.length,z&&!r&&T.unshift(""),T.length?Q.pathname=T.join("/"):(Q.pathname=null,Q.path=null),(!Y0(Q.pathname)||!Y0(Q.search))&&(Q.path=(Q.pathname?Q.pathname:"")+(Q.search?Q.search:"")),Q.auth=X.auth||Q.auth,Q.slashes=Q.slashes||X.slashes,Q.href=Q.format(),Q};s.prototype.parseHost=function(){var X=this.host,q=t0.exec(X);q&&(q=q[0],q!==":"&&(this.port=q.substr(1)),X=X.substr(0,X.length-q.length)),X&&(this.hostname=X)};Z1={parse:a,resolve:A0,resolveObject:D0,format:I0,Url:s,URL:L0,URLSearchParams:$0}});function G1(X,q,Q,Y){function Z(U){return U instanceof Q?U:new Q(function(J){J(U)})}return new(Q||(Q=Promise))(function(U,J){function K(V){try{R(Y.next(V))}catch(E){J(E)}}function G(V){try{R(Y.throw(V))}catch(E){J(E)}}function R(V){V.done?U(V.value):Z(V.value).then(K,G)}R((Y=Y.apply(X,q||[])).next())})}function V1(X,q){var Q={label:0,sent:function(){if(U[0]&1)throw U[1];return U[1]},trys:[],ops:[]},Y,Z,U,J=Object.create((typeof Iterator==="function"?Iterator:Object).prototype);return J.next=K(0),J.throw=K(1),J.return=K(2),typeof Symbol==="function"&&(J[Symbol.iterator]=function(){return this}),J;function K(R){return function(V){return G([R,V])}}function G(R){if(Y)throw new TypeError("Generator is already executing.");while(J&&(J=0,R[0]&&(Q=0)),Q)try{if(Y=1,Z&&(U=R[0]&2?Z.return:R[0]?Z.throw||((U=Z.return)&&U.call(Z),0):Z.next)&&!(U=U.call(Z,R[1])).done)return U;if(Z=0,U)R=[R[0]&2,U.value];switch(R[0]){case 0:case 1:U=R;break;case 4:return Q.label++,{value:R[1],done:!1};case 5:Q.label++,Z=R[1],R=[0];continue;case 7:R=Q.ops.pop(),Q.trys.pop();continue;default:if((U=Q.trys,!(U=U.length>0&&U[U.length-1]))&&(R[0]===6||R[0]===2)){Q=0;continue}if(R[0]===3&&(!U||R[1]>U[0]&&R[1]<U[3])){Q.label=R[1];break}if(R[0]===6&&Q.label<U[1]){Q.label=U[1],U=R;break}if(U&&Q.label<U[2]){Q.label=U[2],Q.ops.push(R);break}if(U[2])Q.ops.pop();Q.trys.pop();continue}R=q.call(X,Q)}catch(V){R=[6,V],Z=0}finally{Y=U=0}if(R[0]&5)throw R[1];return{value:R[0]?R[1]:void 0,done:!0}}}function h0(X){if(X instanceof Uint8Array)return X;if(typeof X==="string")return k1(X);if(ArrayBuffer.isView(X))return new Uint8Array(X.buffer,X.byteOffset,X.byteLength/Uint8Array.BYTES_PER_ELEMENT);return new Uint8Array(X)}function E1(X){if(typeof X==="string")return X.length===0;return X.byteLength===0}function j1(X){var q=h0(X);if(q.byteLength>c){var Q=new Z0;Q.update(q),q=Q.digest()}var Y=new Uint8Array(c);return Y.set(q),Y}var S0=(X,q,Q)=>{if(!q.has(X))throw TypeError("Cannot "+Q)},z0=(X,q,Q)=>{return S0(X,q,"read from private field"),Q?Q.call(X):q.get(X)},_0=(X,q,Q)=>{if(q.has(X))throw TypeError("Cannot add the same private member more than once");q instanceof WeakSet?q.add(X):q.set(X,Q)},w0=(X,q,Q,Y)=>{return S0(X,q,"write to private field"),Y?Y.call(X,Q):q.set(X,Q),Q},U1=async(X,q=X.replace(/c?js$/,"data"),Q=X.replace(/c?js$/,"wasm"))=>{var Y,Z;let U,J,K;const G=/var (.+) = \(/;if(typeof window==="object"){let V=await(await fetch(X)).text();V=`${V}
export default ${(Y=V.match(G))==null?void 0:Y[1]};
`,U=(await import(URL.createObjectURL(new Blob([V],{type:"text/javascript"})))).default,J=await(await fetch(q)).arrayBuffer(),K=new Uint8Array(await(await fetch(Q)).arrayBuffer())}else{const{promises:V}=await import("fs"),{pathToFileURL:E}=await Promise.resolve().then(() => (M0(),C0));let W=await V.readFile(X,{encoding:"utf-8"});W=`
import process from "process";
import * as path from "path";
import { createRequire } from "module";
import { fileURLToPath } from "url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const __filename = fileURLToPath(import.meta.url);
const require = createRequire(import.meta.url);

${W}

export default ${(Z=W.match(G))==null?void 0:Z[1]};
`;const L=X.replace(/c?js$/,"mjs");await V.writeFile(L,W),U=(await import(E(L).href)).default,await V.unlink(L),J=(await V.readFile(q)).buffer,K=(await V.readFile(Q)).buffer}return await U({wasmBinary:K,getPreloadedPackage:(V,E)=>{if(V==="libfaust-wasm.data")return J;return new ArrayBuffer(0)}})},g0=U1,J1=(X,q,Q=!0)=>{const{registerProcessor:Y,AudioWorkletProcessor:Z,sampleRate:U}=globalThis,{FaustBaseWebAudioDsp:J,FaustWasmInstantiator:K}=X,{processorName:G,dspName:R,dspMeta:V,effectMeta:E,poly:W}=q,L=(T)=>{const B=["/gate","/freq","/gain","/key","/vel","/velocity"],I="address"in T&&!!B.find((A)=>T.address.endsWith(A));if(W&&I)return null;if(T.type==="vslider"||T.type==="hslider"||T.type==="nentry")return{name:T.address,defaultValue:T.init||0,minValue:T.min||0,maxValue:T.max||0};else if(T.type==="button"||T.type==="checkbox")return{name:T.address,defaultValue:T.init||0,minValue:0,maxValue:1};return null};class M extends Z{constructor(T){super(T);this.paramValuesCache={},this.port.onmessage=(D)=>this.handleMessageAux(D);const{parameterDescriptors:B}=this.constructor;B.forEach((D)=>{this.paramValuesCache[D.name]=D.defaultValue||0});const{moduleId:I,instanceId:A}=T.processorOptions;if(!I||!A)return;this.wamInfo={moduleId:I,instanceId:A}}static get parameterDescriptors(){const T=[],B=(I)=>{const A=L(I);if(A)T.push(A)};if(J.parseUI(V.ui,B),E)J.parseUI(E.ui,B);return T}setupWamEventHandler(){var T;if(!this.wamInfo)return;const{moduleId:B,instanceId:I}=this.wamInfo,{webAudioModules:A}=globalThis,D=A.getModuleScope(B),h=(T=D==null?void 0:D.paramMgrProcessors)==null?void 0:T[I];if(!h)return;if(h.handleEvent)return;h.handleEvent=(b)=>{if(b.type==="wam-midi")this.midiMessage(b.data.bytes)}}process(T,B,I){for(let A in I){const[D]=I[A];if(D!==this.paramValuesCache[A])this.fDSPCode.setParamValue(A,D),this.paramValuesCache[A]=D}return this.fDSPCode.compute(T[0],B[0])}handleMessageAux(T){const B=T.data;switch(B.type){case"acc":{this.propagateAcc(B.data,B.invert);break}case"gyr":{this.propagateGyr(B.data);break}case"midi":{this.midiMessage(B.data);break}case"ctrlChange":{this.ctrlChange(B.data[0],B.data[1],B.data[2]);break}case"pitchWheel":{this.pitchWheel(B.data[0],B.data[1]);break}case"param":{this.setParamValue(B.data.path,B.data.value);break}case"setPlotHandler":{if(B.data)this.fDSPCode.setPlotHandler((I,A,D)=>this.port.postMessage({type:"plot",value:I,index:A,events:D}));else this.fDSPCode.setPlotHandler(null);break}case"setupWamEventHandler":{this.setupWamEventHandler();break}case"start":{this.fDSPCode.start();break}case"stop":{this.fDSPCode.stop();break}case"destroy":{this.port.close(),this.fDSPCode.destroy();break}default:break}}setParamValue(T,B){this.fDSPCode.setParamValue(T,B),this.paramValuesCache[T]=B}midiMessage(T){this.fDSPCode.midiMessage(T)}ctrlChange(T,B,I){this.fDSPCode.ctrlChange(T,B,I)}pitchWheel(T,B){this.fDSPCode.pitchWheel(T,B)}propagateAcc(T,B=!1){this.fDSPCode.propagateAcc(T,B)}propagateGyr(T){this.fDSPCode.propagateGyr(T)}}class F extends M{constructor(T){super(T);const{FaustMonoWebAudioDsp:B}=X,{factory:I,sampleSize:A}=T.processorOptions,D=K.createSyncMonoDSPInstance(I);this.fDSPCode=new B(D,U,A,128,I.soundfiles),this.fDSPCode.setOutputParamHandler((h,b)=>this.port.postMessage({path:h,value:b,type:"param"})),this.fDSPCode.start()}}class z extends M{constructor(T){super(T);this.handleMessageAux=(N)=>{const H=N.data;switch(H.type){case"keyOn":this.keyOn(H.data[0],H.data[1],H.data[2]);break;case"keyOff":this.keyOff(H.data[0],H.data[1],H.data[2]);break;default:super.handleMessageAux(N);break}};const{FaustPolyWebAudioDsp:B}=X,{voiceFactory:I,mixerModule:A,voices:D,effectFactory:h,sampleSize:b}=T.processorOptions,x=K.createSyncPolyDSPInstance(I,A,D,h),r={...h==null?void 0:h.soundfiles,...I.soundfiles};this.fDSPCode=new B(x,U,b,128,r),this.port.onmessage=(N)=>this.handleMessageAux(N),this.fDSPCode.setOutputParamHandler((N,H)=>this.port.postMessage({path:N,value:H,type:"param"})),this.fDSPCode.start()}midiMessage(T){const B=T[0]>>4,I=T[0]&15,A=T[1],D=T[2];if(B===8||B===9&&D===0)this.keyOff(I,A,D);else if(B===9)this.keyOn(I,A,D);else super.midiMessage(T)}keyOn(T,B,I){this.fDSPCode.keyOn(T,B,I)}keyOff(T,B,I){this.fDSPCode.keyOff(T,B,I)}allNotesOff(T){this.fDSPCode.allNotesOff(T)}}const g=W?z:F;if(Q)try{Y(G||R||(W?"mydsp_poly":"mydsp"),g)}catch(T){console.warn(T)}return W?z:F},K0=J1,K1=(X,q,Q=!0)=>{const{registerProcessor:Y,AudioWorkletProcessor:Z,sampleRate:U}=globalThis,{FaustBaseWebAudioDsp:J,FaustWasmInstantiator:K,FaustMonoWebAudioDsp:G,FFTUtils:R}=X,{processorName:V,dspName:E,dspMeta:W,fftOptions:L}=q,{windowFunctions:M,getFFT:F,fftToSignal:z,signalToFFT:g,signalToNoFFT:T}=R,B=(N,H)=>Math.abs(H)<1?Math.ceil(N*(1/H))/(1/H):Math.ceil(N/H)*H,I=(N,H)=>(N%H+H)%H,A=(N,H)=>{for(let k=0;k<N.length;k++)N[k]*=H(k,N.length)},D=["/fftSize","/fftHopSize","/fftOverlap","/windowFunction","/noIFFT"],h=(N,H,k=0,j=0)=>{const $=N.length,O=H.length,_=Math.min($,O);let v=0,C=I(k,$)||0,w=I(j,O)||0;while(v<_){const y=Math.min(_-v,$-C,O-w),i=w+y;if(w===0&&i===O)N.set(H,C);else N.set(H.subarray(w,i),C);C=(C+y)%$,w=i%O,v+=y}return C},b=(N)=>{if("address"in N&&!!D.find((k)=>N.address.endsWith(k)))return null;if(N.type==="vslider"||N.type==="hslider"||N.type==="nentry")return{name:N.address,defaultValue:N.init||0,minValue:N.min||0,maxValue:N.max||0};else if(N.type==="button"||N.type==="checkbox")return{name:N.address,defaultValue:N.init||0,minValue:0,maxValue:1};return null};class x extends Z{constructor(N){super(N);this.paramValuesCache={},this.destroyed=!1,this.$inputWrite=0,this.$inputRead=0,this.$outputWrite=0,this.$outputRead=0,this.noIFFT=!1,this.fftInput=[],this.fftOutput=[],this.fftOverlap=0,this.fftHopSize=0,this.fftSize=0,this.fftBufferSize=0,this.fPlotHandler=null,this.fCachedEvents=[],this.fBufferNum=0,this.soundfiles={},this.windowFunction=null,this.port.onmessage=(_)=>this.handleMessageAux(_);const{parameterDescriptors:H}=this.constructor;H.forEach((_)=>{this.paramValuesCache[_.name]=_.defaultValue||0});const{factory:k,sampleSize:j}=N.processorOptions;this.dspInstance=K.createSyncMonoDSPInstance(k),this.sampleSize=j,this.soundfiles=k.soundfiles,this.initFFT();const{moduleId:$,instanceId:O}=N.processorOptions;if(!$||!O)return;this.wamInfo={moduleId:$,instanceId:O}}get fftProcessorBufferSize(){return this.fftSize/2+1}async initFFT(){return this.FFT=await F(),await this.createFFTProcessor(),!0}static get parameterDescriptors(){const N=[],H=(k)=>{const j=b(k);if(j)N.push(j)};return J.parseUI(W.ui,H),[...N,{defaultValue:(L==null?void 0:L.fftSize)||1024,maxValue:4294967296,minValue:2,name:"fftSize"},{defaultValue:(L==null?void 0:L.fftOverlap)||2,maxValue:32,minValue:1,name:"fftOverlap"},{defaultValue:typeof(L==null?void 0:L.defaultWindowFunction)==="number"?L.defaultWindowFunction+1:0,maxValue:(M==null?void 0:M.length)||0,minValue:0,name:"windowFunction"},{defaultValue:+!!(L==null?void 0:L.noIFFT)||0,maxValue:1,minValue:0,name:"noIFFT"}]}setupWamEventHandler(){var N;if(!this.wamInfo)return;const{moduleId:H,instanceId:k}=this.wamInfo,{webAudioModules:j}=globalThis,$=j.getModuleScope(H),O=(N=$==null?void 0:$.paramMgrProcessors)==null?void 0:N[k];if(!O)return;if(O.handleEvent)return;O.handleEvent=(_)=>{if(_.type==="wam-midi")this.midiMessage(_.data.bytes)}}processFFT(){let N=I(this.$inputWrite-this.$inputRead,this.fftBufferSize)||this.fftBufferSize;while(N>=this.fftSize){let H=[];this.fDSPCode.compute((k)=>{for(let j=0;j<Math.min(this.fftInput.length,Math.ceil(k.length/3));j++){const $=this.rfft.forward((O)=>{h(O,this.fftInput[j],0,this.$inputRead);for(let _=0;_<O.length;_++)O[_]*=this.window[_]});z($,k[j*3],k[j*3+1],k[j*3+2])}for(let j=this.fftInput.length*3;j<k.length;j++)if(j%3===2)k[j].forEach(($,O)=>k[j][O]=O);else k[j].fill(0)},(k)=>{H=k}),this.$inputRead+=this.fftHopSize,this.$inputRead%=this.fftBufferSize,N-=this.fftHopSize;for(let k=0;k<this.fftOutput.length;k++){let j;if(this.noIFFT)j=this.noIFFTBuffer,T(H[k*2]||this.fftProcessorZeros,H[k*2+1]||this.fftProcessorZeros,j);else j=this.rfft.inverse((O)=>{g(H[k*2]||this.fftProcessorZeros,H[k*2+1]||this.fftProcessorZeros,O)});for(let O=0;O<j.length;O++)j[O]*=this.window[O];let $;for(let O=0;O<j.length-this.fftHopSize;O++)if($=I(this.$outputWrite+O,this.fftBufferSize),this.fftOutput[k][$]+=j[O],k===0)this.windowSumSquare[$]+=this.noIFFT?this.window[O]:this.window[O]**2;for(let O=j.length-this.fftHopSize;O<j.length;O++)if($=I(this.$outputWrite+O,this.fftBufferSize),this.fftOutput[k][$]=j[O],k===0)this.windowSumSquare[$]=this.noIFFT?this.window[O]:this.window[O]**2}this.$outputWrite+=this.fftHopSize,this.$outputWrite%=this.fftBufferSize}}process(N,H,k){if(this.destroyed)return!1;if(!this.FFT)return!0;const j=N[0],$=H[0],O=(j==null?void 0:j.length)||0,_=($==null?void 0:$.length)||0,v=(j==null?void 0:j.length)?Math.max(...j.map((C)=>C.length))||128:128;if(this.noIFFT=!!k.noIFFT[0],this.resetFFT(~~k.fftSize[0],~~k.fftOverlap[0],~~k.windowFunction[0],O,_,v),!this.fDSPCode)return!0;for(let C in k){if(D.find((y)=>`/${C}`.endsWith(y)))continue;const[w]=k[C];if(w!==this.paramValuesCache[C])this.fDSPCode.setParamValue(C,w),this.paramValuesCache[C]=w}if(j==null?void 0:j.length){let C=0;for(let w=0;w<j.length;w++){const y=this.fftInput[w],i=j[w].length?j[w]:new Float32Array(v);C=h(y,i,this.$inputWrite)}this.$inputWrite=C}else this.$inputWrite+=v,this.$inputWrite%=this.fftBufferSize;this.processFFT();for(let C=0;C<$.length;C++){h($[C],this.fftOutput[C],0,this.$outputRead);let w=0;for(let y=0;y<v;y++)w=this.windowSumSquare[I(this.$outputRead+y,this.fftBufferSize)],$[C][y]/=w<0.00000001?1:w}if(this.$outputRead+=v,this.$outputRead%=this.fftBufferSize,this.fPlotHandler)this.port.postMessage({type:"plot",value:$,index:this.fBufferNum++,events:this.fCachedEvents}),this.fCachedEvents=[];return!0}handleMessageAux(N){var H,k,j;const $=N.data;switch($.type){case"midi":this.midiMessage($.data);break;case"ctrlChange":this.ctrlChange($.data[0],$.data[1],$.data[2]);break;case"pitchWheel":this.pitchWheel($.data[0],$.data[1]);break;case"param":this.setParamValue($.data.path,$.data.value);break;case"setPlotHandler":{if($.data)this.fPlotHandler=(O,_,v)=>{if(v)this.fCachedEvents.push(...v)};else this.fPlotHandler=null;(H=this.fDSPCode)==null||H.setPlotHandler(this.fPlotHandler);break}case"setupWamEventHandler":{this.setupWamEventHandler();break}case"start":{(k=this.fDSPCode)==null||k.start();break}case"stop":{(j=this.fDSPCode)==null||j.stop();break}case"destroy":{this.port.close(),this.destroy();break}default:break}}setParamValue(N,H){var k;(k=this.fDSPCode)==null||k.setParamValue(N,H),this.paramValuesCache[N]=H}midiMessage(N){var H;(H=this.fDSPCode)==null||H.midiMessage(N)}ctrlChange(N,H,k){var j;(j=this.fDSPCode)==null||j.ctrlChange(N,H,k)}pitchWheel(N,H){var k;(k=this.fDSPCode)==null||k.pitchWheel(N,H)}resetFFT(N,H,k,j,$,O){var _,v;const C=~~B(Math.max(2,N||1024),2),w=~~Math.min(C,Math.max(1,H)),y=~~Math.max(1,C/w),i=C-Math.min(y,O);let q0=null;if(k!==0)q0=typeof M==="object"?M[~~k-1]||null:null;const Q0=C!==this.fftSize,R0=w!==this.fftOverlap;if(Q0||R0){if(this.fftSize=C,this.fftOverlap=w,this.fftHopSize=y,this.$inputWrite=0,this.$inputRead=0,this.$outputWrite=0,this.$outputRead=-i,this.fftBufferSize=Math.max(C*2-this.fftHopSize,O*2),!Q0&&this.fftHopSizeParam)(_=this.fDSPCode)==null||_.setParamValue(this.fftHopSizeParam,this.fftHopSize)}if(Q0)(v=this.rfft)==null||v.dispose(),this.rfft=new this.FFT(C),this.noIFFTBuffer=new Float32Array(this.fftSize),this.createFFTProcessor();if(Q0||R0||q0!==this.windowFunction){if(this.windowFunction=q0,this.window=new Float32Array(C),this.window.fill(1),q0)A(this.window,q0);this.windowSumSquare=new Float32Array(this.fftBufferSize)}if(this.fftInput.length>j)this.fftInput.splice(j);if(this.fftOutput.length>$)this.fftOutput.splice($);if(Q0||R0){for(let p=0;p<j;p++)this.fftInput[p]=new Float32Array(this.fftBufferSize);for(let p=0;p<$;p++)this.fftOutput[p]=new Float32Array(this.fftBufferSize)}else{if(this.fftInput.length<j)for(let p=this.fftInput.length;p<j;p++)this.fftInput[p]=new Float32Array(this.fftBufferSize);if(this.fftOutput.length<$)for(let p=this.fftOutput.length;p<$;p++)this.fftOutput[p]=new Float32Array(this.fftBufferSize)}}async createFFTProcessor(){var N,H;(N=this.fDSPCode)==null||N.stop(),(H=this.fDSPCode)==null||H.destroy(),this.fDSPCode=new G(this.dspInstance,U,this.sampleSize,this.fftProcessorBufferSize,this.soundfiles),this.fDSPCode.setOutputParamHandler(($,O)=>this.port.postMessage({path:$,value:O,type:"param"})),this.fDSPCode.setPlotHandler(this.fPlotHandler);const k=this.fDSPCode.getParams();this.fDSPCode.start();for(let $ in this.paramValuesCache){if(D.find((O)=>`/${$}`.endsWith(O)))continue;this.fDSPCode.setParamValue($,this.paramValuesCache[$])}const j=k.find(($)=>$.endsWith("/fftSize"));if(j)this.fDSPCode.setParamValue(j,this.fftSize);if(this.fftHopSizeParam=k.find(($)=>$.endsWith("/fftHopSize")),this.fftHopSizeParam)this.fDSPCode.setParamValue(this.fftHopSizeParam,this.fftHopSize);this.fftProcessorZeros=new Float32Array(this.fftProcessorBufferSize)}destroy(){var N,H,k;(N=this.fDSPCode)==null||N.stop(),(H=this.fDSPCode)==null||H.destroy(),(k=this.rfft)==null||k.dispose(),this.destroyed=!0}}const r=x;if(Q)try{Y(V||E||"myfftdsp",r)}catch(N){console.warn(N)}return x},R1=K1,c=64,T1=32,L1=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),W1=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225],N1=Math.pow(2,53)-1,Z0=function(){function X(){this.state=Int32Array.from(W1),this.temp=new Int32Array(64),this.buffer=new Uint8Array(64),this.bufferLength=0,this.bytesHashed=0,this.finished=!1}return X.prototype.update=function(q){if(this.finished)throw new Error("Attempted to update an already finished hash.");var Q=0,Y=q.byteLength;if(this.bytesHashed+=Y,this.bytesHashed*8>N1)throw new Error("Cannot hash more than 2^53 - 1 bits");while(Y>0)if(this.buffer[this.bufferLength++]=q[Q++],Y--,this.bufferLength===c)this.hashBuffer(),this.bufferLength=0},X.prototype.digest=function(){if(!this.finished){var q=this.bytesHashed*8,Q=new DataView(this.buffer.buffer,this.buffer.byteOffset,this.buffer.byteLength),Y=this.bufferLength;if(Q.setUint8(this.bufferLength++,128),Y%c>=c-8){for(var Z=this.bufferLength;Z<c;Z++)Q.setUint8(Z,0);this.hashBuffer(),this.bufferLength=0}for(var Z=this.bufferLength;Z<c-8;Z++)Q.setUint8(Z,0);Q.setUint32(c-8,Math.floor(q/4294967296),!0),Q.setUint32(c-4,q),this.hashBuffer(),this.finished=!0}var U=new Uint8Array(T1);for(var Z=0;Z<8;Z++)U[Z*4]=this.state[Z]>>>24&255,U[Z*4+1]=this.state[Z]>>>16&255,U[Z*4+2]=this.state[Z]>>>8&255,U[Z*4+3]=this.state[Z]>>>0&255;return U},X.prototype.hashBuffer=function(){var q=this,Q=q.buffer,Y=q.state,Z=Y[0],U=Y[1],J=Y[2],K=Y[3],G=Y[4],R=Y[5],V=Y[6],E=Y[7];for(var W=0;W<c;W++){if(W<16)this.temp[W]=(Q[W*4]&255)<<24|(Q[W*4+1]&255)<<16|(Q[W*4+2]&255)<<8|Q[W*4+3]&255;else{var L=this.temp[W-2],M=(L>>>17|L<<15)^(L>>>19|L<<13)^L>>>10;L=this.temp[W-15];var F=(L>>>7|L<<25)^(L>>>18|L<<14)^L>>>3;this.temp[W]=(M+this.temp[W-7]|0)+(F+this.temp[W-16]|0)}var z=(((G>>>6|G<<26)^(G>>>11|G<<21)^(G>>>25|G<<7))+(G&R^~G&V)|0)+(E+(L1[W]+this.temp[W]|0)|0)|0,g=((Z>>>2|Z<<30)^(Z>>>13|Z<<19)^(Z>>>22|Z<<10))+(Z&U^Z&J^U&J)|0;E=V,V=R,R=G,G=K+z|0,K=J,J=U,U=Z,Z=z+g|0}Y[0]+=Z,Y[1]+=U,Y[2]+=J,Y[3]+=K,Y[4]+=G,Y[5]+=R,Y[6]+=V,Y[7]+=E},X}(),B1=(X)=>new TextEncoder().encode(X),k1=typeof Buffer!=="undefined"&&Buffer.from?function(X){return Buffer.from(X,"utf8")}:B1,H1=function(){function X(q){this.secret=q,this.hash=new Z0,this.reset()}return X.prototype.update=function(q){if(E1(q)||this.error)return;try{this.hash.update(h0(q))}catch(Q){this.error=Q}},X.prototype.digestSync=function(){if(this.error)throw this.error;if(this.outer){if(!this.outer.finished)this.outer.update(this.hash.digest());return this.outer.digest()}return this.hash.digest()},X.prototype.digest=function(){return G1(this,void 0,void 0,function(){return V1(this,function(q){return[2,this.digestSync()]})})},X.prototype.reset=function(){if(this.hash=new Z0,this.secret){this.outer=new Z0;var q=j1(this.secret),Q=new Uint8Array(c);Q.set(q);for(var Y=0;Y<c;Y++)q[Y]^=54,Q[Y]^=92;this.hash.update(q),this.outer.update(Q);for(var Y=0;Y<q.byteLength;Y++)q[Y]=0}},X}(),$1=(X)=>String.fromCharCode.apply(null,X),O1=(X)=>{const q=new ArrayBuffer(X.length),Q=new Uint8Array(q);for(let Y=0,Z=X.length;Y<Z;Y++)Q[Y]=X.charCodeAt(Y);return Q},I1=async(X)=>{const q=new H1;return q.update(X),Array.from(await q.digest()).map((Z)=>Z.toString(16).padStart(2,"0")).join("")},b0=class X{static serializeDSPFactories(){const q={};return this.gFactories.forEach((Q,Y)=>{const{code:Z,json:U,poly:J}=Q;q[Y]={code:btoa($1(Z)),json:JSON.parse(U),poly:J}}),q}static stringifyDSPFactories(){return JSON.stringify(this.serializeDSPFactories())}static deserializeDSPFactories(q){const Q=[];for(let Y in q){const Z=q[Y],{code:U,json:J,poly:K}=Z,G=O1(atob(U));Q.push(WebAssembly.compile(G).then((R)=>this.gFactories.set(Y,{shaKey:Y,cfactory:0,code:G,module:R,json:JSON.stringify(J),poly:K,soundfiles:{}})))}return Promise.all(Q)}static importDSPFactories(q){const Q=JSON.parse(q);return this.deserializeDSPFactories(Q)}constructor(q){this.fLibFaust=q,this.fErrorMessage=""}intVec2intArray(q){const Q=q.size(),Y=new Uint8Array(Q);for(let Z=0;Z<Q;Z++)Y[Z]=q.get(Z);return Y}async createDSPFactory(q,Q,Y,Z){if(X.gFactories.size>10)X.gFactories.clear();let U=await I1(q+Q+Y+(Z?"poly":"mono"));if(X.gFactories.has(U))return X.gFactories.get(U)||null;else try{const J=this.fLibFaust.createDSPFactory(q,Q,Y,!Z),K=this.intVec2intArray(J.data);J.data.delete();const G=await WebAssembly.compile(K),R={shaKey:U,cfactory:J.cfactory,code:K,module:G,json:J.json,poly:Z,soundfiles:{}};return this.deleteDSPFactory(R),X.gFactories.set(U,R),R}catch(J){throw this.fErrorMessage=this.fLibFaust.getErrorAfterException(),this.fLibFaust.cleanupAfterException(),this.fErrorMessage?new Error(this.fErrorMessage):J}}version(){return this.fLibFaust.version()}getErrorMessage(){return this.fErrorMessage}async createMonoDSPFactory(q,Q,Y){return this.createDSPFactory(q,Q,Y,!1)}async createPolyDSPFactory(q,Q,Y){return this.createDSPFactory(q,Q,Y,!0)}deleteDSPFactory(q){this.fLibFaust.deleteDSPFactory(q.cfactory),q.cfactory=0}expandDSP(q,Q){try{return this.fLibFaust.expandDSP("FaustDSP",q,Q)}catch(Y){throw this.fErrorMessage=this.fLibFaust.getErrorAfterException(),this.fLibFaust.cleanupAfterException(),this.fErrorMessage?new Error(this.fErrorMessage):Y}}generateAuxFiles(q,Q,Y){try{return this.fLibFaust.generateAuxFiles(q,Q,Y)}catch(Z){throw this.fErrorMessage=this.fLibFaust.getErrorAfterException(),this.fLibFaust.cleanupAfterException(),this.fErrorMessage?new Error(this.fErrorMessage):Z}}deleteAllDSPFactories(){this.fLibFaust.deleteAllDSPFactories()}fs(){return this.fLibFaust.fs()}async getAsyncInternalMixerModule(q=!1){const Q=q?"mixer64Buffer":"mixer32Buffer",Y=q?"mixer64Module":"mixer32Module";if(this[Y])return{mixerBuffer:this[Q],mixerModule:this[Y]};const Z=q?"/usr/rsrc/mixer64.wasm":"/usr/rsrc/mixer32.wasm",U=this.fs().readFile(Z,{encoding:"binary"});this[Q]=U;const J=await WebAssembly.compile(U);return this[Y]=J,{mixerBuffer:U,mixerModule:J}}getSyncInternalMixerModule(q=!1){const Q=q?"mixer64Buffer":"mixer32Buffer",Y=q?"mixer64Module":"mixer32Module";if(this[Y])return{mixerBuffer:this[Q],mixerModule:this[Y]};const Z=q?"/usr/rsrc/mixer64.wasm":"/usr/rsrc/mixer32.wasm",U=this.fs().readFile(Z,{encoding:"binary"});this[Q]=U;const J=new WebAssembly.Module(U);return this[Y]=J,{mixerBuffer:U,mixerModule:J}}};b0.gFactories=new Map;var A1=b0,F0=A1,u=class{constructor(X){this.fExports=X}compute(X,q,Q,Y){this.fExports.compute(X,q,Q,Y)}getNumInputs(X){return this.fExports.getNumInputs(X)}getNumOutputs(X){return this.fExports.getNumOutputs(X)}getParamValue(X,q){return this.fExports.getParamValue(X,q)}getSampleRate(X){return this.fExports.getSampleRate(X)}init(X,q){this.fExports.init(X,q)}instanceClear(X){this.fExports.instanceClear(X)}instanceConstants(X,q){this.fExports.instanceConstants(X,q)}instanceInit(X,q){this.fExports.instanceInit(X,q)}instanceResetUserInterface(X){this.fExports.instanceResetUserInterface(X)}setParamValue(X,q,Q){this.fExports.setParamValue(X,q,Q)}},D1=class{static createWasmImport(X){return{env:{memory:X||new WebAssembly.Memory({initial:100}),memoryBase:0,tableBase:0,_abs:Math.abs,_acosf:Math.acos,_asinf:Math.asin,_atanf:Math.atan,_atan2f:Math.atan2,_ceilf:Math.ceil,_cosf:Math.cos,_expf:Math.exp,_floorf:Math.floor,_fmodf:(q,Q)=>q%Q,_logf:Math.log,_log10f:Math.log10,_max_f:Math.max,_min_f:Math.min,_remainderf:(q,Q)=>q-Math.round(q/Q)*Q,_powf:Math.pow,_roundf:Math.round,_sinf:Math.sin,_sqrtf:Math.sqrt,_tanf:Math.tan,_acoshf:Math.acosh,_asinhf:Math.asinh,_atanhf:Math.atanh,_coshf:Math.cosh,_sinhf:Math.sinh,_tanhf:Math.tanh,_isnanf:Number.isNaN,_isinff:(q)=>!isFinite(q),_copysignf:(q,Q)=>Math.sign(q)===Math.sign(Q)?q:-q,_acos:Math.acos,_asin:Math.asin,_atan:Math.atan,_atan2:Math.atan2,_ceil:Math.ceil,_cos:Math.cos,_exp:Math.exp,_floor:Math.floor,_fmod:(q,Q)=>q%Q,_log:Math.log,_log10:Math.log10,_max_:Math.max,_min_:Math.min,_remainder:(q,Q)=>q-Math.round(q/Q)*Q,_pow:Math.pow,_round:Math.round,_sin:Math.sin,_sqrt:Math.sqrt,_tan:Math.tan,_acosh:Math.acosh,_asinh:Math.asinh,_atanh:Math.atanh,_cosh:Math.cosh,_sinh:Math.sinh,_tanh:Math.tanh,_isnan:Number.isNaN,_isinf:(q)=>!isFinite(q),_copysign:(q,Q)=>Math.sign(q)===Math.sign(Q)?q:-q,table:new WebAssembly.Table({initial:0,element:"anyfunc"})}}}static createWasmMemoryPoly(X,q,Q,Y,Z){const U=Math.max(4,X),J=q,K=(V)=>{let E=65536;while(E<V)E*=2;return E},G=Y?Y.size:0;let R=K(G+Q.size*U+(Q.inputs+Q.outputs*2)*(J+Z*q))/65536;return R=Math.max(2,R),new WebAssembly.Memory({initial:R})}static createWasmMemoryMono(X,q,Q){const Y=X,Z=(q.size+(q.inputs+q.outputs)*(Y+Q*X))/65536;return new WebAssembly.Memory({initial:Z*2})}static createMonoDSPInstanceAux(X,q,Q=null){const Y=X.exports,Z=new u(Y);return{memory:Q?Q:X.exports.memory,api:Z,json:q}}static createMemoryMono(X){const q=JSON.parse(X.json),Q=q.compile_options.match("-double")?8:4;return this.createWasmMemoryMono(Q,q,8192)}static createMemoryPoly(X,q,Q){const Y=JSON.parse(q.json),Z=Q&&Q.json?JSON.parse(Q.json):null,U=Y.compile_options.match("-double")?8:4;return this.createWasmMemoryPoly(X,U,Y,Z,8192)}static createMixerAux(X,q){const Q={imports:{print:console.log},memory:{memory:q}};return new WebAssembly.Instance(X,Q).exports}static async loadDSPFactory(X,q){const Q=await fetch(X);if(!Q.ok)throw new Error(`=> exception raised while running loadDSPFactory, file not found: ${X}`);try{const Y=await Q.arrayBuffer(),Z=await WebAssembly.compile(Y),J=await(await fetch(q)).text(),R=JSON.parse(J).compile_options.indexOf("wasm-e")!==-1;return{cfactory:0,code:new Uint8Array(Y),module:Z,json:J,poly:R}}catch(Y){throw Y}}static async loadDSPMixer(X,q){try{let Q=null;if(q)Q=q.readFile(X,{encoding:"binary"});else Q=await(await fetch(X)).arrayBuffer();return WebAssembly.compile(Q)}catch(Q){throw Q}}static async createAsyncMonoDSPInstance(X){if(/"type":\s*"soundfile"/.test(X.json)){const Y=this.createMemoryMono(X),Z=await WebAssembly.instantiate(X.module,this.createWasmImport(Y));return this.createMonoDSPInstanceAux(Z,X.json,Y)}else{const Y=await WebAssembly.instantiate(X.module,this.createWasmImport());return this.createMonoDSPInstanceAux(Y,X.json)}}static createSyncMonoDSPInstance(X){if(/"type":\s*"soundfile"/.test(X.json)){const Y=this.createMemoryMono(X),Z=new WebAssembly.Instance(X.module,this.createWasmImport(Y));return this.createMonoDSPInstanceAux(Z,X.json,Y)}else{const Y=new WebAssembly.Instance(X.module,this.createWasmImport());return this.createMonoDSPInstanceAux(Y,X.json)}}static async createAsyncPolyDSPInstance(X,q,Q,Y){const Z=this.createMemoryPoly(Q,X,Y),J=(await WebAssembly.instantiate(X.module,this.createWasmImport(Z))).exports,K=new u(J),G=this.createMixerAux(q,Z);if(Y){const V=(await WebAssembly.instantiate(Y.module,this.createWasmImport(Z))).exports,E=new u(V);return{memory:Z,voices:Q,voiceAPI:K,effectAPI:E,mixerAPI:G,voiceJSON:X.json,effectJSON:Y.json}}else return{memory:Z,voices:Q,voiceAPI:K,mixerAPI:G,voiceJSON:X.json}}static createSyncPolyDSPInstance(X,q,Q,Y){const Z=this.createMemoryPoly(Q,X,Y),J=new WebAssembly.Instance(X.module,this.createWasmImport(Z)).exports,K=new u(J),G=this.createMixerAux(q,Z);if(Y){const V=new WebAssembly.Instance(Y.module,this.createWasmImport(Z)).exports,E=new u(V);return{memory:Z,voices:Q,voiceAPI:K,effectAPI:E,mixerAPI:G,voiceJSON:X.json,effectJSON:Y.json}}else return{memory:Z,voices:Q,voiceAPI:K,mixerAPI:G,voiceJSON:X.json}}},d=D1,l=class X{static convertToAxis(q){switch(q){case 0:return 0;case 1:return 1;case 2:return 2;default:return console.error("Error: Axis not found value: "+q),0}}static convertToCurve(q){switch(q){case 0:return 0;case 1:return 1;case 2:return 2;case 3:return 3;default:return console.error("Error: Curve not found value: "+q),0}}static get Range(){if(!this._Range)this._Range=class{constructor(q,Q){this.fLo=Math.min(q,Q),this.fHi=Math.max(q,Q)}clip(q){if(q<this.fLo)return this.fLo;if(q>this.fHi)return this.fHi;return q}};return this._Range}static get Interpolator(){if(!this._Interpolator)this._Interpolator=class{constructor(q,Q,Y,Z){if(this.fRange=new X.Range(q,Q),Q!==q)this.fCoef=(Z-Y)/(Q-q),this.fOffset=Y-q*this.fCoef;else this.fCoef=0,this.fOffset=(Y+Z)/2}returnMappedValue(q){var Q=this.fRange.clip(q);return this.fOffset+Q*this.fCoef}getLowHigh(q,Q){return{amin:this.fRange.fLo,amax:this.fRange.fHi}}};return this._Interpolator}static get Interpolator3pt(){if(!this._Interpolator3pt)this._Interpolator3pt=class{constructor(q,Q,Y,Z,U,J){this.fSegment1=new X.Interpolator(q,Q,Z,U),this.fSegment2=new X.Interpolator(Q,Y,U,J),this.fMid=Q}returnMappedValue(q){return q<this.fMid?this.fSegment1.returnMappedValue(q):this.fSegment2.returnMappedValue(q)}getMappingValues(q,Q,Y){var Z=this.fSegment1.getLowHigh(q,Q),U=this.fSegment2.getLowHigh(Q,Y);return{amin:Z.amin,amid:U.amin,amax:U.amax}}};return this._Interpolator3pt}static get UpConverter(){if(!this._UpConverter)this._UpConverter=class{constructor(q,Q,Y,Z,U,J){this.fActive=!0,this.fA2F=new X.Interpolator3pt(q,Q,Y,Z,U,J),this.fF2A=new X.Interpolator3pt(Z,U,J,q,Q,Y)}uiToFaust(q){return this.fA2F.returnMappedValue(q)}faustToUi(q){return this.fF2A.returnMappedValue(q)}setMappingValues(q,Q,Y,Z,U,J){this.fA2F=new X.Interpolator3pt(q,Q,Y,Z,U,J),this.fF2A=new X.Interpolator3pt(Z,U,J,q,Q,Y)}getMappingValues(q,Q,Y){return this.fA2F.getMappingValues(q,Q,Y)}setActive(q){this.fActive=q}getActive(){return this.fActive}};return this._UpConverter}static get DownConverter(){if(!this._DownConverter)this._DownConverter=class{constructor(q,Q,Y,Z,U,J){this.fActive=!0,this.fA2F=new X.Interpolator3pt(q,Q,Y,J,U,Z),this.fF2A=new X.Interpolator3pt(Z,U,J,Y,Q,q)}uiToFaust(q){return this.fA2F.returnMappedValue(q)}faustToUi(q){return this.fF2A.returnMappedValue(q)}setMappingValues(q,Q,Y,Z,U,J){this.fA2F=new X.Interpolator3pt(q,Q,Y,J,U,Z),this.fF2A=new X.Interpolator3pt(Z,U,J,Y,Q,q)}getMappingValues(q,Q,Y){return this.fA2F.getMappingValues(q,Q,Y)}setActive(q){this.fActive=q}getActive(){return this.fActive}};return this._DownConverter}static get UpDownConverter(){if(!this._UpDownConverter)this._UpDownConverter=class{constructor(q,Q,Y,Z,U,J){this.fActive=!0,this.fA2F=new X.Interpolator3pt(q,Q,Y,Z,J,Z),this.fF2A=new X.Interpolator(Z,J,q,Y)}uiToFaust(q){return this.fA2F.returnMappedValue(q)}faustToUi(q){return this.fF2A.returnMappedValue(q)}setMappingValues(q,Q,Y,Z,U,J){this.fA2F=new X.Interpolator3pt(q,Q,Y,Z,J,Z),this.fF2A=new X.Interpolator(Z,J,q,Y)}getMappingValues(q,Q,Y){return this.fA2F.getMappingValues(q,Q,Y)}setActive(q){this.fActive=q}getActive(){return this.fActive}};return this._UpDownConverter}static get DownUpConverter(){if(!this._DownUpConverter)this._DownUpConverter=class{constructor(q,Q,Y,Z,U,J){this.fActive=!0,this.fA2F=new X.Interpolator3pt(q,Q,Y,J,Z,J),this.fF2A=new X.Interpolator(Z,J,q,Y)}uiToFaust(q){return this.fA2F.returnMappedValue(q)}faustToUi(q){return this.fF2A.returnMappedValue(q)}setMappingValues(q,Q,Y,Z,U,J){this.fA2F=new X.Interpolator3pt(q,Q,Y,J,Z,J),this.fF2A=new X.Interpolator(Z,J,q,Y)}getMappingValues(q,Q,Y){return this.fA2F.getMappingValues(q,Q,Y)}setActive(q){this.fActive=q}getActive(){return this.fActive}};return this._DownUpConverter}static buildHandler(q,Q,Y,Z,U,J,K){switch(q){case 0:return new X.UpConverter(Q,Y,Z,U,J,K);case 1:return new X.DownConverter(Q,Y,Z,U,J,K);case 2:return new X.UpDownConverter(Q,Y,Z,U,J,K);case 3:return new X.DownUpConverter(Q,Y,Z,U,J,K);default:return new X.UpConverter(Q,Y,Z,U,J,K)}}},m=class{constructor(X,q){this.memory=X,this.allocatedBytes=q}alloc(X){const q=this.allocatedBytes,Q=q+X,Y=this.memory.buffer.byteLength;if(Q>Y){const Z=Math.ceil((Q-Y)/65536);console.log(`GROW: ${Z} pages`),this.memory.grow(Z)}return this.allocatedBytes=Q,q}getBuffer(){return this.memory.buffer}getInt32Array(){return new Int32Array(this.memory.buffer)}getInt64Array(){return new BigInt64Array(this.memory.buffer)}getFloat32Array(){return new Float32Array(this.memory.buffer)}getFloat64Array(){return new Float64Array(this.memory.buffer)}},f=class X{static get MAX_SOUNDFILE_PARTS(){return 256}static get MAX_CHAN(){return 64}static get BUFFER_SIZE(){return 1024}static get SAMPLE_RATE(){return 44100}constructor(q,Q,Y,Z,U,J){this.fSampleSize=Q,this.fIntSize=this.fSampleSize,this.fPtrSize=4,this.fAllocator=q,console.log(`Soundfile constructor: curChan: ${Y}, length: ${Z}, maxChan: ${U}, totalParts: ${J}`),this.fPtr=q.alloc(4*this.fPtrSize),this.fLength=q.alloc(X.MAX_SOUNDFILE_PARTS*this.fIntSize),this.fSR=q.alloc(X.MAX_SOUNDFILE_PARTS*this.fIntSize),this.fOffset=q.alloc(X.MAX_SOUNDFILE_PARTS*this.fIntSize),this.fBuffers=this.allocBuffers(Y,Z,U);const K=this.fAllocator.getInt32Array();K[this.fPtr>>2]=this.fBuffers,K[this.fPtr+this.fPtrSize>>2]=this.fLength,K[this.fPtr+2*this.fPtrSize>>2]=this.fSR,K[this.fPtr+3*this.fPtrSize>>2]=this.fOffset;for(let G=0;G<Y;G++){const R=K[(this.fBuffers>>2)+G];console.log(`allocBuffers AFTER: ${G} - ${R}`)}}allocBuffers(q,Q,Y){const Z=this.fAllocator.alloc(Y*this.fPtrSize);console.log(`allocBuffers buffers: ${Z}`);for(let U=0;U<q;U++){const J=this.fAllocator.alloc(Q*this.fSampleSize),K=this.fAllocator.getInt32Array();K[(Z>>2)+U]=J}return Z}shareBuffers(q,Q){const Y=this.fAllocator.getInt32Array();for(let Z=q;Z<Q;Z++)Y[(this.fBuffers>>2)+Z]=Y[(this.fBuffers>>2)+Z%q]}copyToOut(q,Q,Y,Z){if(this.fIntSize===4){const U=this.fAllocator.getInt32Array();U[(this.fLength>>Math.log2(this.fIntSize))+q]=Z.audioBuffer[0].length,U[(this.fSR>>Math.log2(this.fIntSize))+q]=Z.sampleRate,U[(this.fOffset>>Math.log2(this.fIntSize))+q]=Y}else{const U=this.fAllocator.getInt64Array();U[(this.fLength>>Math.log2(this.fIntSize))+q]=BigInt(Z.audioBuffer[0].length),U[(this.fSR>>Math.log2(this.fIntSize))+q]=BigInt(Z.sampleRate),U[(this.fOffset>>Math.log2(this.fIntSize))+q]=BigInt(Y)}if(console.log(`copyToOut: part: ${q}, maxChannels: ${Q}, offset: ${Y}, buffer: ${Z}`),this.fSampleSize===8)this.copyToOutReal64(Q,Y,Z);else this.copyToOutReal32(Q,Y,Z)}copyToOutReal32(q,Q,Y){const Z=this.fAllocator.getInt32Array(),U=this.fAllocator.getFloat32Array();for(let J=0;J<Y.audioBuffer.length;J++){const K=Y.audioBuffer[J],G=Z[(this.fBuffers>>2)+J],R=G+Q*this.fSampleSize>>Math.log2(this.fSampleSize),V=G+(Q+K.length)*this.fSampleSize>>Math.log2(this.fSampleSize);console.log(`copyToOutReal32 begin: ${R}, end: ${V}, delta: ${V-R}`);const E=U.subarray(G+Q*this.fSampleSize>>Math.log2(this.fSampleSize),G+(Q+K.length)*this.fSampleSize>>Math.log2(this.fSampleSize));for(let W=0;W<K.length;W++)E[W]=K[W]}}copyToOutReal64(q,Q,Y){const Z=this.fAllocator.getInt32Array(),U=this.fAllocator.getFloat64Array();for(let J=0;J<Y.audioBuffer.length;J++){const K=Y.audioBuffer[J],G=Z[(this.fBuffers>>2)+J],R=G+Q*this.fSampleSize>>Math.log2(this.fSampleSize),V=G+(Q+K.length)*this.fSampleSize>>Math.log2(this.fSampleSize);console.log(`copyToOutReal64 begin: ${R}, end: ${V}, delta: ${V-R}`);const E=U.subarray(G+Q*this.fSampleSize>>Math.log2(this.fSampleSize),G+(Q+K.length)*this.fSampleSize>>Math.log2(this.fSampleSize));for(let W=0;W<K.length;W++)E[W]=K[W]}}emptyFile(q,Q){if(this.fIntSize===4){const Y=this.fAllocator.getInt32Array();Y[(this.fLength>>Math.log2(this.fIntSize))+q]=X.BUFFER_SIZE,Y[(this.fSR>>Math.log2(this.fIntSize))+q]=X.SAMPLE_RATE,Y[(this.fOffset>>Math.log2(this.fIntSize))+q]=Q}else{const Y=this.fAllocator.getInt64Array();Y[(this.fLength>>Math.log2(this.fIntSize))+q]=BigInt(X.BUFFER_SIZE),Y[(this.fSR>>Math.log2(this.fIntSize))+q]=BigInt(X.SAMPLE_RATE),Y[(this.fOffset>>Math.log2(this.fIntSize))+q]=BigInt(Q)}return Q+X.BUFFER_SIZE}displayMemory(q="",Q=!1){console.log("Soundfile memory: "+q),console.log(`fPtr: ${this.fPtr}`),console.log(`fBuffers: ${this.fBuffers}`),console.log(`fLength: ${this.fLength}`),console.log(`fSR: ${this.fSR}`),console.log(`fOffset: ${this.fOffset}`);const Y=this.fAllocator.getInt32Array();if(Q)console.log(`HEAP32: ${Y}`);console.log(`HEAP32[this.fPtr >> 2]: ${Y[this.fPtr>>2]}`),console.log(`HEAP32[(this.fPtr + ptrSize) >> 2]: ${Y[this.fPtr+this.fPtrSize>>2]}`),console.log(`HEAP32[(this.fPtr + 2 * ptrSize) >> 2]: ${Y[this.fPtr+2*this.fPtrSize>>2]}`),console.log(`HEAP32[(this.fPtr + 3 * ptrSize) >> 2]: ${Y[this.fPtr+3*this.fPtrSize>>2]}`)}getPtr(){return this.fPtr}getHEAP32(){return this.fAllocator.getInt32Array()}getHEAPFloat32(){return this.fAllocator.getFloat32Array()}getHEAPFloat64(){return this.fAllocator.getFloat64Array()}},P=class X{constructor(q,Q,Y){this.fOutputHandler=null,this.fComputeHandler=null,this.fPlotHandler=null,this.fCachedEvents=[],this.fBufferNum=0,this.fInChannels=[],this.fOutChannels=[],this.fOutputsTimer=5,this.fInputsItems=[],this.fOutputsItems=[],this.fDescriptor=[],this.fSoundfiles=[],this.fSoundfileBuffers={},this.fPitchwheelLabel=[],this.fCtrlLabel=new Array(128).fill(null).map(()=>[]),this.fPathTable={},this.fUICallback=(Z)=>{if(Z.type==="hbargraph"||Z.type==="vbargraph")this.fOutputsItems.push(Z.address),this.fPathTable[Z.address]=Z.index;else if(Z.type==="vslider"||Z.type==="hslider"||Z.type==="button"||Z.type==="checkbox"||Z.type==="nentry"){if(this.fInputsItems.push(Z.address),this.fPathTable[Z.address]=Z.index,this.fDescriptor.push(Z),!Z.meta)return;Z.meta.forEach((U)=>{const{midi:J,acc:K,gyr:G}=U;if(J){const R=J.trim();if(R==="pitchwheel"){const V=R.match(/^pitchwheel\s(\d+)/);if(V)this.fPitchwheelLabel.push({path:Z.address,chan:parseInt(V[1]),min:Z.min,max:Z.max});else this.fPitchwheelLabel.push({path:Z.address,chan:0,min:Z.min,max:Z.max})}else{const V=R.match(/^ctrl\s(\d+)\s(\d+)/),E=R.match(/^ctrl\s(\d+)/);if(V)this.fCtrlLabel[parseInt(V[1])].push({path:Z.address,chan:parseInt(V[2]),min:Z.min,max:Z.max});else if(E)this.fCtrlLabel[parseInt(E[1])].push({path:Z.address,chan:0,min:Z.min,max:Z.max})}}if(K){const R=K.trim().split(" ").map(Number);this.setupAccHandler(Z.address,l.convertToAxis(R[0]),l.convertToCurve(R[1]),R[2],R[3],R[4],Z.min,Z.init,Z.max)}if(G){const R=G.trim().split(" ").map(Number);this.setupGyrHandler(Z.address,l.convertToAxis(R[0]),l.convertToCurve(R[1]),R[2],R[3],R[4],Z.min,Z.init,Z.max)}})}else if(Z.type==="soundfile")this.fSoundfiles.push({name:Z.label,url:Z.url,index:Z.index,basePtr:-1})},this.fProcessing=!1,this.fDestroyed=!1,this.fFirstCall=!0,this.fBufferSize=Q,this.fPtrSize=q,this.fSampleSize=q,this.fSoundfileBuffers=Y,this.fAcc={x:[],y:[],z:[]},this.fGyr={x:[],y:[],z:[]}}static remap(q,Q,Y,Z,U){return(q-Q)/(Y-Q)*(U-Z)+Z}static parseUI(q,Q){q.forEach((Y)=>this.parseGroup(Y,Q))}static parseGroup(q,Q){if(q.items)this.parseItems(q.items,Q)}static parseItems(q,Q){q.forEach((Y)=>this.parseItem(Y,Q))}static parseItem(q,Q){if(q.type==="vgroup"||q.type==="hgroup"||q.type==="tgroup")this.parseItems(q.items,Q);else Q(q)}static splitSoundfileNames(q){return q.replace(/^\{|\}$/g,"").split(";").map((Y)=>Y.length<=2?"":Y.substring(1,Y.length-1))}get hasAccInput(){return this.fAcc.x.length+this.fAcc.y.length+this.fAcc.z.length>0}propagateAcc(q,Q=!1){const{x:Y,y:Z,z:U}=q;if(Q){if(Y!==null)this.fAcc.x.forEach((J)=>J(-Y));if(Z!==null)this.fAcc.y.forEach((J)=>J(-Z));if(U!==null)this.fAcc.z.forEach((J)=>J(-U))}else{if(Y!==null)this.fAcc.x.forEach((J)=>J(Y));if(Z!==null)this.fAcc.y.forEach((J)=>J(Z));if(U!==null)this.fAcc.z.forEach((J)=>J(U))}}get hasGyrInput(){return this.fGyr.x.length+this.fGyr.y.length+this.fGyr.z.length>0}propagateGyr(q){const{alpha:Q,beta:Y,gamma:Z}=q;if(Q!==null)this.fGyr.x.forEach((U)=>U(Q));if(Y!==null)this.fGyr.y.forEach((U)=>U(Y));if(Z!==null)this.fGyr.z.forEach((U)=>U(Z))}setupAccHandler(q,Q,Y,Z,U,J,K,G,R){const V=l.buildHandler(Y,Z,U,J,K,G,R);switch(Q){case 0:this.fAcc.x.push((E)=>this.setParamValue(q,V.uiToFaust(E)));break;case 1:this.fAcc.y.push((E)=>this.setParamValue(q,V.uiToFaust(E)));break;case 2:this.fAcc.z.push((E)=>this.setParamValue(q,V.uiToFaust(E)));break}}setupGyrHandler(q,Q,Y,Z,U,J,K,G,R){const V=l.buildHandler(Y,Z,U,J,K,G,R);switch(Q){case 0:this.fGyr.x.push((E)=>this.setParamValue(q,V.uiToFaust(E)));break;case 1:this.fGyr.y.push((E)=>this.setParamValue(q,V.uiToFaust(E)));break;case 2:this.fGyr.z.push((E)=>this.setParamValue(q,V.uiToFaust(E)));break}}static extractUrlsFromMeta(q){const Q=q.meta.find((Y)=>Y.soundfiles!==void 0);if(Q)return Q.soundfiles.split(";").filter((Y)=>Y!=="");else return[]}loadSoundfile(q,Q,Y,Z){console.log(`Soundfile ${Y} paths: ${Z}`);const U=X.splitSoundfileNames(Z),J=this.fSoundfiles.find((K)=>K.url===Z);if(!J)throw new Error(`Soundfile with ${Z} cannot be found !}`);if(J.basePtr!==-1){const K=q.getInt32Array();console.log(`Soundfile CACHE ${Z}} : ${Y} loaded at ${J.basePtr} in wasm memory with index ${J.index}`),K[Q+J.index>>2]=J.basePtr}else{const K=this.createSoundfile(q,U,this.fSoundfileBuffers);if(K){const G=K.getHEAP32();J.basePtr=K.getPtr(),console.log(`Soundfile ${Y} loaded at ${J.basePtr} in wasm memory with index ${J.index}`),G[Q+J.index>>2]=J.basePtr}else console.log(`Soundfile ${Y} for ${Z} cannot be created !}`)}}createSoundfile(q,Q,Y,Z=f.MAX_CHAN){let U=1,J=0;for(let R of Q){let V=0,E=0;const W=Y[R];if(W)V=W.audioBuffer.length,E=W.audioBuffer[0].length;else E=f.BUFFER_SIZE,V=1;U=Math.max(U,V),J+=E}J+=(f.MAX_SOUNDFILE_PARTS-Q.length)*f.BUFFER_SIZE;const K=new f(q,this.fSampleSize,U,J,Z,Q.length);let G=0;for(let R=0;R<Q.length;R++){const V=Q[R],E=Y[V];if(E)K.copyToOut(R,Z,G,E),G+=E.audioBuffer[0].length;else G=K.emptyFile(R,G)}for(let R=Q.length;R<f.MAX_SOUNDFILE_PARTS;R++)G=K.emptyFile(R,G);return K.shareBuffers(U,Z),K}initSoundfileMemory(q,Q){for(let{name:Y,url:Z}of this.fSoundfiles)this.loadSoundfile(q,Q,Y,Z)}updateOutputs(){if(this.fOutputsItems.length>0&&this.fOutputHandler&&this.fOutputsTimer--===0)this.fOutputsTimer=5,this.fOutputsItems.forEach((q)=>{var Q;return(Q=this.fOutputHandler)==null?void 0:Q.call(this,q,this.getParamValue(q))})}metadata(q){if(this.fJSONDsp.meta)this.fJSONDsp.meta.forEach((Q)=>q(Object.keys(Q)[0],Q[Object.keys(Q)[0]]))}compute(q,Q){return!1}setOutputParamHandler(q){this.fOutputHandler=q}getOutputParamHandler(){return this.fOutputHandler}setComputeHandler(q){this.fComputeHandler=q}getComputeHandler(){return this.fComputeHandler}setPlotHandler(q){this.fPlotHandler=q}getPlotHandler(){return this.fPlotHandler}getNumInputs(){return-1}getNumOutputs(){return-1}midiMessage(q){if(this.fPlotHandler)this.fCachedEvents.push({data:q,type:"midi"});const Q=q[0]>>4,Y=q[0]&15,Z=q[1],U=q[2];if(Q===11)return this.ctrlChange(Y,Z,U);if(Q===14)return this.pitchWheel(Y,U*128+Z)}ctrlChange(q,Q,Y){if(this.fPlotHandler)this.fCachedEvents.push({type:"ctrlChange",data:[q,Q,Y]});if(this.fCtrlLabel[Q].length)this.fCtrlLabel[Q].forEach((Z)=>{const{path:U,chan:J}=Z;if(J===0||q===J-1){if(this.setParamValue(U,X.remap(Y,0,127,Z.min,Z.max)),this.fOutputHandler)this.fOutputHandler(U,this.getParamValue(U))}})}pitchWheel(q,Q){if(this.fPlotHandler)this.fCachedEvents.push({type:"pitchWheel",data:[q,Q]});this.fPitchwheelLabel.forEach((Y)=>{const{path:Z,chan:U}=Y;if(U===0||q===U-1){if(this.setParamValue(Z,X.remap(Q,0,16383,Y.min,Y.max)),this.fOutputHandler)this.fOutputHandler(Z,this.getParamValue(Z))}})}setParamValue(q,Q){}getParamValue(q){return 0}getParams(){return this.fInputsItems}getMeta(){return this.fJSONDsp}getJSON(){return JSON.stringify(this.getMeta())}getUI(){return this.fJSONDsp.ui}getDescriptors(){return this.fDescriptor}hasSoundfiles(){return this.fSoundfiles.length>0}start(){this.fProcessing=!0}stop(){this.fProcessing=!1}destroy(){this.fDestroyed=!0,this.fOutputHandler=null,this.fComputeHandler=null,this.fPlotHandler=null}},n=class extends P{constructor(X,q,Q,Y,Z){super(Q,Y,Z);if(this.fInstance=X,console.log(`sampleSize: ${Q} bufferSize: ${Y}`),this.fJSONDsp=JSON.parse(this.fInstance.json),P.parseUI(this.fJSONDsp.ui,this.fUICallback),this.fEndMemory=this.initMemory(),this.fInstance.api.init(this.fDSP,q),this.fSoundfiles.length>0){const U=new m(this.fInstance.memory,this.fEndMemory);this.initSoundfileMemory(U,this.fDSP)}}initMemory(){this.fDSP=0;const X=this.fJSONDsp.size;this.fAudioInputs=X,this.fAudioOutputs=this.fAudioInputs+this.getNumInputs()*this.fPtrSize;const q=this.fAudioOutputs+this.getNumOutputs()*this.fPtrSize,Q=q+this.getNumInputs()*this.fBufferSize*this.fSampleSize,Y=Q+this.getNumOutputs()*this.fBufferSize*this.fSampleSize,Z=this.fInstance.memory.buffer,U=new Int32Array(Z),J=this.fSampleSize===4?new Float32Array(Z):new Float64Array(Z);if(this.getNumInputs()>0){for(let G=0;G<this.getNumInputs();G++)U[(this.fAudioInputs>>2)+G]=q+this.fBufferSize*this.fSampleSize*G;const K=U.subarray(this.fAudioInputs>>2,this.fAudioInputs+this.getNumInputs()*this.fPtrSize>>2);for(let G=0;G<this.getNumInputs();G++)this.fInChannels[G]=J.subarray(K[G]>>Math.log2(this.fSampleSize),K[G]+this.fBufferSize*this.fSampleSize>>Math.log2(this.fSampleSize))}if(this.getNumOutputs()>0){for(let G=0;G<this.getNumOutputs();G++)U[(this.fAudioOutputs>>2)+G]=Q+this.fBufferSize*this.fSampleSize*G;const K=U.subarray(this.fAudioOutputs>>2,this.fAudioOutputs+this.getNumOutputs()*this.fPtrSize>>2);for(let G=0;G<this.getNumOutputs();G++)this.fOutChannels[G]=J.subarray(K[G]>>Math.log2(this.fSampleSize),K[G]+this.fBufferSize*this.fSampleSize>>Math.log2(this.fSampleSize))}return Y}toString(){return`============== Mono Memory layout ==============
        this.fBufferSize: ${this.fBufferSize}
        this.fJSONDsp.size: ${this.fJSONDsp.size}
        this.fAudioInputs: ${this.fAudioInputs}
        this.fAudioOutputs: ${this.fAudioOutputs}
        this.fDSP: ${this.fDSP}`}compute(X,q){if(this.fDestroyed)return!1;if(!this.fProcessing)return!0;if(this.fFirstCall)this.initMemory(),this.fFirstCall=!1;if(typeof X==="function")X(this.fInChannels);else{if(this.getNumInputs()>0&&(!X||!X[0]||X[0].length===0))return!0;if(this.getNumOutputs()>0&&typeof q!=="function"&&(!q||!q[0]||q[0].length===0))return!0;if(X!==void 0)for(let Y=0;Y<Math.min(this.getNumInputs(),X.length);Y++)this.fInChannels[Y].set(X[Y])}if(this.fComputeHandler)this.fComputeHandler(this.fBufferSize);this.fInstance.api.compute(this.fDSP,this.fBufferSize,this.fAudioInputs,this.fAudioOutputs),this.updateOutputs();let Q=this.fOutChannels;if(typeof q==="function")q(this.fOutChannels);else{for(let Y=0;Y<Math.min(this.getNumOutputs(),q.length);Y++){const Z=this.fOutChannels[Y];q[Y].set(Z)}Q=q}if(this.fPlotHandler)this.fPlotHandler(Q,this.fBufferNum++,this.fCachedEvents.length?this.fCachedEvents:void 0),this.fCachedEvents=[];return!0}metadata(X){super.metadata(X)}getNumInputs(){return this.fInstance.api.getNumInputs(this.fDSP)}getNumOutputs(){return this.fInstance.api.getNumOutputs(this.fDSP)}setParamValue(X,q){if(this.fPlotHandler)this.fCachedEvents.push({type:"param",data:{path:X,value:q}});this.fInstance.api.setParamValue(this.fDSP,this.fPathTable[X],q)}getParamValue(X){return this.fInstance.api.getParamValue(this.fDSP,this.fPathTable[X])}getMeta(){return this.fJSONDsp}getJSON(){return this.fInstance.json}getDescriptors(){return this.fDescriptor}getUI(){return this.fJSONDsp.ui}},S=class X{constructor(q,Q,Y,Z,U){this.fFreqLabel=[],this.fGateLabel=[],this.fGainLabel=[],this.fKeyLabel=[],this.fVelLabel=[],this.fCurNote=X.kFreeVoice,this.fNextNote=-1,this.fNextVel=-1,this.fDate=0,this.fLevel=0,this.fRelease=0,this.fDSP=q,this.fAPI=Q,this.fAPI.init(this.fDSP,U),this.extractPaths(Y,Z)}static get kActiveVoice(){return 0}static get kFreeVoice(){return-1}static get kReleaseVoice(){return-2}static get kLegatoVoice(){return-3}static get kNoVoice(){return-4}static get VOICE_STOP_LEVEL(){return 0.0005}static midiToFreq(q){return 440*2**((q-69)/12)}static normalizeVelocity(q){return q/127}extractPaths(q,Q){q.forEach((Y)=>{if(Y.endsWith("/gate"))this.fGateLabel.push(Q[Y]);else if(Y.endsWith("/freq"))this.fFreqLabel.push(Q[Y]);else if(Y.endsWith("/key"))this.fKeyLabel.push(Q[Y]);else if(Y.endsWith("/gain"))this.fGainLabel.push(Q[Y]);else if(Y.endsWith("/vel")&&Y.endsWith("/velocity"))this.fVelLabel.push(Q[Y])})}keyOn(q,Q,Y=!1){if(Y)this.fNextNote=q,this.fNextVel=Q;else this.fFreqLabel.forEach((Z)=>this.fAPI.setParamValue(this.fDSP,Z,X.midiToFreq(q))),this.fGateLabel.forEach((Z)=>this.fAPI.setParamValue(this.fDSP,Z,1)),this.fGainLabel.forEach((Z)=>this.fAPI.setParamValue(this.fDSP,Z,X.normalizeVelocity(Q))),this.fKeyLabel.forEach((Z)=>this.fAPI.setParamValue(this.fDSP,Z,q)),this.fVelLabel.forEach((Z)=>this.fAPI.setParamValue(this.fDSP,Z,Q)),this.fCurNote=q}keyOff(q=!1){if(this.fGateLabel.forEach((Q)=>this.fAPI.setParamValue(this.fDSP,Q,0)),q)this.fCurNote=X.kFreeVoice;else this.fRelease=this.fAPI.getSampleRate(this.fDSP)/2,this.fCurNote=X.kReleaseVoice}computeLegato(q,Q,Y,Z){let U=q/2;this.fGateLabel.forEach((J)=>this.fAPI.setParamValue(this.fDSP,J,0)),this.fAPI.compute(this.fDSP,U,Q,Y),this.keyOn(this.fNextNote,this.fNextVel),this.fAPI.compute(this.fDSP,U,Q,Z)}compute(q,Q,Y){this.fAPI.compute(this.fDSP,q,Q,Y)}setParamValue(q,Q){this.fAPI.setParamValue(this.fDSP,q,Q)}getParamValue(q){return this.fAPI.getParamValue(this.fDSP,q)}},e=class X extends P{constructor(q,Q,Y,Z,U){super(Y,Z,U);if(this.fInstance=q,console.log(`sampleSize: ${Y} bufferSize: ${Z}`),this.fJSONDsp=JSON.parse(this.fInstance.voiceJSON),this.fJSONEffect=this.fInstance.effectAPI&&this.fInstance.effectJSON?JSON.parse(this.fInstance.effectJSON):null,P.parseUI(this.fJSONDsp.ui,this.fUICallback),this.fJSONEffect)P.parseUI(this.fJSONEffect.ui,this.fUICallback);this.fEndMemory=this.initMemory(),this.fVoiceTable=[];for(let J=0;J<this.fInstance.voices;J++)this.fVoiceTable.push(new S(this.fJSONDsp.size*J,this.fInstance.voiceAPI,this.fInputsItems,this.fPathTable,Q));if(this.fInstance.effectAPI)this.fInstance.effectAPI.init(this.fEffect,Q);if(this.fSoundfiles.length>0){const J=new m(this.fInstance.memory,this.fEndMemory);for(let K=0;K<this.fInstance.voices;K++)this.initSoundfileMemory(J,this.fJSONDsp.size*K)}}initMemory(){this.fEffect=this.fJSONDsp.size*this.fInstance.voices;const q=this.fEffect+(this.fJSONEffect?this.fJSONEffect.size:0);this.fAudioInputs=q,this.fAudioOutputs=this.fAudioInputs+this.getNumInputs()*this.fPtrSize,this.fAudioMixing=this.fAudioOutputs+this.getNumOutputs()*this.fPtrSize,this.fAudioMixingHalf=this.fAudioMixing+this.getNumOutputs()*this.fPtrSize;const Q=this.fAudioMixingHalf+this.getNumOutputs()*this.fPtrSize,Y=Q+this.getNumInputs()*this.fBufferSize*this.fSampleSize,Z=Y+this.getNumOutputs()*this.fBufferSize*this.fSampleSize,U=Z+this.getNumOutputs()*this.fBufferSize*this.fSampleSize,J=this.fInstance.memory.buffer,K=new Int32Array(J),G=this.fSampleSize===4?new Float32Array(J):new Float64Array(J);if(this.getNumInputs()>0){for(let V=0;V<this.getNumInputs();V++)K[(this.fAudioInputs>>2)+V]=Q+this.fBufferSize*this.fSampleSize*V;const R=K.subarray(this.fAudioInputs>>2,this.fAudioInputs+this.getNumInputs()*this.fPtrSize>>2);for(let V=0;V<this.getNumInputs();V++)this.fInChannels[V]=G.subarray(R[V]>>Math.log2(this.fSampleSize),R[V]+this.fBufferSize*this.fSampleSize>>Math.log2(this.fSampleSize))}if(this.getNumOutputs()>0){for(let V=0;V<this.getNumOutputs();V++)K[(this.fAudioOutputs>>2)+V]=Y+this.fBufferSize*this.fSampleSize*V,K[(this.fAudioMixing>>2)+V]=Z+this.fBufferSize*this.fSampleSize*V,K[(this.fAudioMixingHalf>>2)+V]=Z+this.fBufferSize*this.fSampleSize*V+this.fBufferSize/2*this.fSampleSize;const R=K.subarray(this.fAudioOutputs>>2,this.fAudioOutputs+this.getNumOutputs()*this.fPtrSize>>2);for(let V=0;V<this.getNumOutputs();V++)this.fOutChannels[V]=G.subarray(R[V]>>Math.log2(this.fSampleSize),R[V]+this.fBufferSize*this.fSampleSize>>Math.log2(this.fSampleSize))}return U}toString(){return`============== Poly Memory layout ==============
        this.fBufferSize: ${this.fBufferSize}
        this.fJSONDsp.size: ${this.fJSONDsp.size}
        this.fAudioInputs: ${this.fAudioInputs}
        this.fAudioOutputs: ${this.fAudioOutputs}
        this.fAudioMixing: ${this.fAudioMixing}
        this.fAudioMixingHalf: ${this.fAudioMixingHalf}`}allocVoice(q,Q){return this.fVoiceTable[q].fDate++,this.fVoiceTable[q].fCurNote=Q,q}getPlayingVoice(q){let Q=S.kNoVoice,Y=Number.MAX_VALUE;for(let Z=0;Z<this.fInstance.voices;Z++)if(this.fVoiceTable[Z].fCurNote===q){if(this.fVoiceTable[Z].fDate<Y)Y=this.fVoiceTable[Z].fDate,Q=Z}return Q}getFreeVoice(){for(let U=0;U<this.fInstance.voices;U++)if(this.fVoiceTable[U].fCurNote===S.kFreeVoice)return this.allocVoice(U,S.kActiveVoice);let{kNoVoice:q,kNoVoice:Q}=S,Y=Number.MAX_VALUE,Z=Number.MAX_VALUE;for(let U=0;U<this.fInstance.voices;U++)if(this.fVoiceTable[U].fCurNote===S.kReleaseVoice){if(this.fVoiceTable[U].fDate<Y)Y=this.fVoiceTable[U].fDate,q=U}else if(this.fVoiceTable[U].fDate<Z)Z=this.fVoiceTable[U].fDate,Q=U;if(Y!==Number.MAX_VALUE)return console.log(`Steal release voice : voice_date = ${this.fVoiceTable[q].fDate} voice = ${q}`),this.allocVoice(q,S.kLegatoVoice);if(Z!==Number.MAX_VALUE)return console.log(`Steal playing voice : voice_date = ${this.fVoiceTable[Q].fDate} voice = ${Q}`),this.allocVoice(Q,S.kLegatoVoice);return S.kNoVoice}compute(q,Q){if(this.fDestroyed)return!1;if(this.fFirstCall)this.initMemory(),this.fFirstCall=!1;if(!this.fProcessing)return!0;if(this.getNumInputs()>0&&(!q||!q[0]||q[0].length===0))return!0;if(this.getNumOutputs()>0&&(!Q||!Q[0]||Q[0].length===0))return!0;if(q!==void 0)for(let Y=0;Y<Math.min(this.getNumInputs(),q.length);++Y)this.fInChannels[Y].set(q[Y]);if(this.fComputeHandler)this.fComputeHandler(this.fBufferSize);if(this.fInstance.mixerAPI.clearOutput(this.fBufferSize,this.getNumOutputs(),this.fAudioOutputs),this.fVoiceTable.forEach((Y)=>{if(Y.fCurNote===S.kLegatoVoice)Y.computeLegato(this.fBufferSize,this.fAudioInputs,this.fAudioMixing,this.fAudioMixingHalf),this.fInstance.mixerAPI.fadeOut(this.fBufferSize/2,this.getNumOutputs(),this.fAudioMixing),Y.fLevel=this.fInstance.mixerAPI.mixCheckVoice(this.fBufferSize,this.getNumOutputs(),this.fAudioMixing,this.fAudioOutputs);else if(Y.fCurNote!==S.kFreeVoice){if(Y.compute(this.fBufferSize,this.fAudioInputs,this.fAudioMixing),Y.fLevel=this.fInstance.mixerAPI.mixCheckVoice(this.fBufferSize,this.getNumOutputs(),this.fAudioMixing,this.fAudioOutputs),Y.fRelease-=this.fBufferSize,Y.fCurNote==S.kReleaseVoice&&(Y.fLevel<S.VOICE_STOP_LEVEL&&Y.fRelease<0))Y.fCurNote=S.kFreeVoice}}),this.fInstance.effectAPI)this.fInstance.effectAPI.compute(this.fEffect,this.fBufferSize,this.fAudioOutputs,this.fAudioOutputs);if(this.updateOutputs(),Q!==void 0){for(let Y=0;Y<Math.min(this.getNumOutputs(),Q.length);Y++){const Z=this.fOutChannels[Y];Q[Y].set(Z)}if(this.fPlotHandler)this.fPlotHandler(Q,this.fBufferNum++,this.fCachedEvents.length?this.fCachedEvents:void 0),this.fCachedEvents=[]}return!0}getNumInputs(){return this.fInstance.voiceAPI.getNumInputs(0)}getNumOutputs(){return this.fInstance.voiceAPI.getNumOutputs(0)}static findPath(q,Q){if(typeof q!=="object")return!1;else if(q.address)return q.address===Q;else{for(let Y in q)if(X.findPath(q[Y],Q))return!0;return!1}}setParamValue(q,Q){if(this.fPlotHandler)this.fCachedEvents.push({type:"param",data:{path:q,value:Q}});if(this.fJSONEffect&&X.findPath(this.fJSONEffect.ui,q)&&this.fInstance.effectAPI)this.fInstance.effectAPI.setParamValue(this.fEffect,this.fPathTable[q],Q);else this.fVoiceTable.forEach((Y)=>Y.setParamValue(this.fPathTable[q],Q))}getParamValue(q){if(this.fJSONEffect&&X.findPath(this.fJSONEffect.ui,q)&&this.fInstance.effectAPI)return this.fInstance.effectAPI.getParamValue(this.fEffect,this.fPathTable[q]);else return this.fVoiceTable[0].getParamValue(this.fPathTable[q])}getMeta(){const q=this.fJSONDsp,Q=this.fJSONEffect,Y={...q};if(Q)Y.ui=[{type:"tgroup",label:"Sequencer",items:[{type:"vgroup",label:"Instrument",items:q.ui},{type:"vgroup",label:"Effect",items:Q.ui}]}];else Y.ui=[{type:"tgroup",label:"Polyphonic",items:[{type:"vgroup",label:"Voices",items:q.ui}]}];return Y}getJSON(){return JSON.stringify(this.getMeta())}getUI(){return this.getMeta().ui}getDescriptors(){return this.fDescriptor}midiMessage(q){const Q=q[0]>>4,Y=q[0]&15,Z=q[1],U=q[2];if(Q===8||Q===9&&U===0)return this.keyOff(Y,Z,U);else if(Q===9)return this.keyOn(Y,Z,U);else super.midiMessage(q)}ctrlChange(q,Q,Y){if(Q===123||Q===120)this.allNotesOff(!0);else super.ctrlChange(q,Q,Y)}keyOn(q,Q,Y){if(this.fPlotHandler)this.fCachedEvents.push({type:"keyOn",data:[q,Q,Y]});const Z=this.getFreeVoice();this.fVoiceTable[Z].keyOn(Q,Y,this.fVoiceTable[Z].fCurNote==S.kLegatoVoice)}keyOff(q,Q,Y){if(this.fPlotHandler)this.fCachedEvents.push({type:"keyOff",data:[q,Q,Y]});const Z=this.getPlayingVoice(Q);if(Z!==S.kNoVoice)this.fVoiceTable[Z].keyOff();else console.log("Playing pitch = %d not found\n",Q)}allNotesOff(q=!0){this.fCachedEvents.push({type:"ctrlChange",data:[0,123,0]}),this.fVoiceTable.forEach((Q)=>Q.keyOff(q))}},x0=class{constructor(X,q){this.fDSPCode=X,this.fBufferSize=q,this.fInputs=new Array(this.fDSPCode.getNumInputs()).fill(null).map(()=>new Float32Array(q)),this.fOutputs=new Array(this.fDSPCode.getNumOutputs()).fill(null).map(()=>new Float32Array(q))}getParameterDescriptors(){const X=[],q=(Q)=>{let Y=null;const Z=["/gate","/freq","/gain","/key","/vel","/velocity"],U="address"in Q&&!!Z.find((J)=>Q.address.endsWith(J));if(this.fDSPCode instanceof n||!U){if(Q.type==="vslider"||Q.type==="hslider"||Q.type==="nentry")Y={name:Q.address,defaultValue:Q.init||0,minValue:Q.min||0,maxValue:Q.max||0};else if(Q.type==="button"||Q.type==="checkbox")Y={name:Q.address,defaultValue:Q.init||0,minValue:0,maxValue:1}}if(Y)X.push(Y)};return P.parseUI(this.fDSPCode.getUI(),q),X}compute(X,q){return this.fDSPCode.compute(X,q)}setOutputParamHandler(X){this.fDSPCode.setOutputParamHandler(X)}getOutputParamHandler(){return this.fDSPCode.getOutputParamHandler()}setComputeHandler(X){this.fDSPCode.setComputeHandler(X)}getComputeHandler(){return this.fDSPCode.getComputeHandler()}setPlotHandler(X){this.fDSPCode.setPlotHandler(X)}getPlotHandler(){return this.fDSPCode.getPlotHandler()}getNumInputs(){return this.fDSPCode.getNumInputs()}getNumOutputs(){return this.fDSPCode.getNumOutputs()}metadata(X){}midiMessage(X){this.fDSPCode.midiMessage(X)}ctrlChange(X,q,Q){this.fDSPCode.ctrlChange(X,q,Q)}pitchWheel(X,q){this.fDSPCode.pitchWheel(X,q)}setParamValue(X,q){this.fDSPCode.setParamValue(X,q)}getParamValue(X){return this.fDSPCode.getParamValue(X)}getParams(){return this.fDSPCode.getParams()}getMeta(){return this.fDSPCode.getMeta()}getJSON(){return this.fDSPCode.getJSON()}getDescriptors(){return this.fDSPCode.getDescriptors()}getUI(){return this.fDSPCode.getUI()}start(){this.fDSPCode.start()}stop(){this.fDSPCode.stop()}destroy(){this.fDSPCode.destroy()}get hasAccInput(){return this.fDSPCode.hasAccInput}propagateAcc(X,q=!1){this.fDSPCode.propagateAcc(X,q)}get hasGyrInput(){return this.fDSPCode.hasGyrInput}propagateGyr(X){this.fDSPCode.propagateGyr(X)}render(X=[],q=this.fBufferSize,Q){let Y=0;const Z=new Array(this.fDSPCode.getNumOutputs()).fill(null).map(()=>new Float32Array(q));this.fDSPCode.start();while(Y<q){const U=Math.min(q-Y,this.fBufferSize);for(let J=0;J<this.fDSPCode.getNumInputs();J++){let K;if(X[J])if(X[J].length<=Y)K=new Float32Array(U);else if(X[J].length>Y+U)K=X[J].subarray(Y,Y+U);else K=X[J].subarray(Y,X[J].length);else K=new Float32Array(U);this.fInputs[J]=K}this.fDSPCode.compute(this.fInputs,this.fOutputs);for(let J=0;J<this.fDSPCode.getNumOutputs();J++){const K=this.fOutputs[J];if(U<this.fBufferSize)Z[J].set(K.subarray(0,U),Y);else Z[J].set(K,Y)}Y+=this.fBufferSize,Q==null||Q(Y)}return this.fDSPCode.stop(),Z}},C1=class extends x0{},M1=class extends x0{keyOn(X,q,Q){this.fDSPCode.keyOn(X,q,Q)}keyOff(X,q,Q){this.fDSPCode.keyOff(X,q,Q)}allNotesOff(X){this.fDSPCode.allNotesOff(X)}};var z1=class{constructor(X){this.fModule=X,this.fCompiler=new X.libFaustWasm,this.fFileSystem=this.fModule.FS}module(){return this.fModule}fs(){return this.fFileSystem}version(){return this.fCompiler.version()}createDSPFactory(X,q,Q,Y){return this.fCompiler.createDSPFactory(X,q,Q,Y)}deleteDSPFactory(X){return this.fCompiler.deleteDSPFactory(X)}expandDSP(X,q,Q){return this.fCompiler.expandDSP(X,q,Q)}generateAuxFiles(X,q,Q){return this.fCompiler.generateAuxFiles(X,q,Q)}deleteAllDSPFactories(){return this.fCompiler.deleteAllDSPFactories()}getErrorAfterException(){return this.fCompiler.getErrorAfterException()}cleanupAfterException(){return this.fCompiler.cleanupAfterException()}getInfos(X){return this.fCompiler.getInfos(X)}toString(){return`LibFaust module: ${this.fModule}, compiler: ${this.fCompiler}`}},v0=z1;var _1=class{static get fallbackPaths(){return[location.href,this.getParentUrl(location.href),location.origin]}static getParentUrl(X){return X.substring(0,X.lastIndexOf("/")+1)}static toAudioData(X){const{sampleRate:q,numberOfChannels:Q}=X;return{sampleRate:q,audioBuffer:new Array(Q).fill(null).map((Y,Z)=>X.getChannelData(Z))}}static findSoundfilesFromMeta(X){const q={},Q=(Y)=>{if(Y.type==="soundfile")P.splitSoundfileNames(Y.url).forEach((U)=>q[U]=null)};return P.parseUI(X.ui,Q),q}static async checkFileExists(X){try{console.log(`"checkFileExists" url: ${X}`);const q=await fetch(X);return console.log(`"checkFileExists" response.ok: ${q.ok}`),q.ok}catch(q){return console.error("Fetch error:",q),!1}}static async fetchSoundfile(X,q){console.log(`Loading sound file from ${X}`);const Q=await fetch(X);if(!Q.ok)throw new Error(`Failed to load sound file from ${X}: ${Q.statusText}`);const Y=await Q.arrayBuffer(),Z=await q.decodeAudioData(Y);return this.toAudioData(Z)}static async loadSoundfile(X,q,Q,Y){if(Q[X])return;const Z=[X,...[...q,...this.fallbackPaths].map((K)=>new URL(X,K.endsWith("/")?K:`${K}/`).href)],J=(await Promise.all(Z.map((K)=>this.checkFileExists(K)))).findIndex((K)=>!!K);if(J===-1)throw new Error(`Failed to load sound file ${X}, all check failed.`);Q[X]=await this.fetchSoundfile(Z[J],Y)}static async loadSoundfiles(X,q,Q){const Y=P.extractUrlsFromMeta(X),Z=this.findSoundfilesFromMeta(X);for(let U in Z){if(q[U]){Z[U]=q[U];continue}try{await this.loadSoundfile(U,Y,Z,Q)}catch(J){console.error(J)}}return Z}},o=_1,U0,J0,y0=class extends(globalThis.AudioWorkletNode||null){constructor(X,q,Q,Y={}){const Z=JSON.parse(Q.json);super(X,q,{numberOfInputs:Z.inputs>0?1:0,numberOfOutputs:Z.outputs>0?1:0,channelCount:Math.max(1,Z.inputs),outputChannelCount:[Z.outputs],channelCountMode:"explicit",channelInterpretation:"speakers",processorOptions:Y.processorOptions,...Y});_0(this,U0,!1),_0(this,J0,!1),this.handleDeviceMotion=({accelerationIncludingGravity:U})=>{const J=/Android/i.test(navigator.userAgent);if(!U)return;const{x:K,y:G,z:R}=U;this.propagateAcc({x:K,y:G,z:R},J)},this.handleDeviceOrientation=({alpha:U,beta:J,gamma:K})=>{this.propagateGyr({alpha:U,beta:J,gamma:K})},this.fJSONDsp=Z,this.fJSON=Q.json,this.fOutputHandler=null,this.fComputeHandler=null,this.fPlotHandler=null,this.fDescriptor=[],this.fInputsItems=[],this.fUICallback=(U)=>{if(U.type==="vslider"||U.type==="hslider"||U.type==="button"||U.type==="checkbox"||U.type==="nentry"){if(this.fInputsItems.push(U.address),this.fDescriptor.push(U),!U.meta)return;U.meta.forEach((J)=>{const{midi:K,acc:G,gyr:R}=J;if(G)w0(this,U0,!0);if(R)w0(this,J0,!0)})}},P.parseUI(this.fJSONDsp.ui,this.fUICallback),this.port.onmessage=(U)=>{if(U.data.type==="param"&&this.fOutputHandler)this.fOutputHandler(U.data.path,U.data.value);else if(U.data.type==="plot"&&this.fPlotHandler)this.fPlotHandler(U.data.value,U.data.index,U.data.events)}}async startSensors(){if(this.hasAccInput)if(window.DeviceMotionEvent)if(typeof window.DeviceMotionEvent.requestPermission==="function")try{const X=await window.DeviceMotionEvent.requestPermission();if(X==="granted")window.addEventListener("devicemotion",this.handleDeviceMotion,!0);else if(X==="denied")throw alert("You have denied access to motion and orientation data. To enable it, go to Settings > Safari > Motion & Orientation Access."),new Error("Unable to access the accelerometer.")}catch(X){console.error(X)}else window.addEventListener("devicemotion",this.handleDeviceMotion,!0);else console.log("Cannot set the accelerometer handler.");if(this.hasGyrInput)if(window.DeviceMotionEvent)if(typeof window.DeviceOrientationEvent.requestPermission==="function")try{const X=await window.DeviceOrientationEvent.requestPermission();if(X==="granted")window.addEventListener("deviceorientation",this.handleDeviceOrientation,!0);else if(X==="denied")throw alert("You have denied access to motion and orientation data. To enable it, go to Settings > Safari > Motion & Orientation Access."),new Error("Unable to access the gyroscope.")}catch(X){console.error(X)}else window.addEventListener("deviceorientation",this.handleDeviceOrientation,!0);else console.log("Cannot set the gyroscope handler.")}stopSensors(){if(this.hasAccInput)window.removeEventListener("devicemotion",this.handleDeviceMotion,!0);if(this.hasGyrInput)window.removeEventListener("deviceorientation",this.handleDeviceOrientation,!0)}setOutputParamHandler(X){this.fOutputHandler=X}getOutputParamHandler(){return this.fOutputHandler}setComputeHandler(X){this.fComputeHandler=X}getComputeHandler(){return this.fComputeHandler}setPlotHandler(X){if(this.fPlotHandler=X,this.fPlotHandler)this.port.postMessage({type:"setPlotHandler",data:!0});else this.port.postMessage({type:"setPlotHandler",data:!1})}getPlotHandler(){return this.fPlotHandler}setupWamEventHandler(){this.port.postMessage({type:"setupWamEventHandler"})}getNumInputs(){return this.fJSONDsp.inputs}getNumOutputs(){return this.fJSONDsp.outputs}compute(X,q){return!1}metadata(X){if(this.fJSONDsp.meta)this.fJSONDsp.meta.forEach((q)=>X(Object.keys(q)[0],q[Object.keys(q)[0]]))}midiMessage(X){const q=X[0]>>4,Q=X[0]&15,Y=X[1],Z=X[2];if(q===11)this.ctrlChange(Q,Y,Z);else if(q===14)this.pitchWheel(Q,Z*128+Y);else this.port.postMessage({type:"midi",data:X})}ctrlChange(X,q,Q){const Y={type:"ctrlChange",data:[X,q,Q]};this.port.postMessage(Y)}pitchWheel(X,q){const Q={type:"pitchWheel",data:[X,q]};this.port.postMessage(Q)}get hasAccInput(){return z0(this,U0)}propagateAcc(X,q=!1){if(!X)return;const Q={type:"acc",data:X,invert:q};this.port.postMessage(Q)}get hasGyrInput(){return z0(this,J0)}propagateGyr(X){if(!X)return;const q={type:"gyr",data:X};this.port.postMessage(q)}setParamValue(X,q){const Q={type:"param",data:{path:X,value:q}};this.port.postMessage(Q);const Y=this.parameters.get(X);if(Y)Y.setValueAtTime(q,this.context.currentTime)}getParamValue(X){const q=this.parameters.get(X);return q?q.value:0}getParams(){return this.fInputsItems}getMeta(){return this.fJSONDsp}getJSON(){return JSON.stringify(this.getMeta())}getUI(){return this.fJSONDsp.ui}getDescriptors(){return this.fDescriptor}start(){this.port.postMessage({type:"start"})}stop(){this.port.postMessage({type:"stop"})}destroy(){this.port.postMessage({type:"destroy"}),this.port.close()}};U0=new WeakMap;J0=new WeakMap;var P0=class extends y0{constructor(X,q){super(X,q.processorOptions.name,q.processorOptions.factory,q);this.onprocessorerror=(Q)=>{throw Q}}},w1=class extends y0{constructor(X,q){super(X,q.processorOptions.name,q.processorOptions.voiceFactory,q);if(this.onprocessorerror=(Q)=>{throw Q},this.fJSONEffect=q.processorOptions.effectFactory?JSON.parse(q.processorOptions.effectFactory.json):null,this.fJSONEffect)P.parseUI(this.fJSONEffect.ui,this.fUICallback)}keyOn(X,q,Q){const Y={type:"keyOn",data:[X,q,Q]};this.port.postMessage(Y)}keyOff(X,q,Q){const Y={type:"keyOff",data:[X,q,Q]};this.port.postMessage(Y)}allNotesOff(X){const q={type:"ctrlChange",data:[0,123,0]};this.port.postMessage(q)}getMeta(){const X=this.fJSONDsp,q=this.fJSONEffect,Q={...X};if(q)Q.ui=[{type:"tgroup",label:"Sequencer",items:[{type:"vgroup",label:"Instrument",items:X.ui},{type:"vgroup",label:"Effect",items:q.ui}]}];else Q.ui=[{type:"tgroup",label:"Polyphonic",items:[{type:"vgroup",label:"Voices",items:X.ui}]}];return Q}getJSON(){return JSON.stringify(this.getMeta())}getUI(){return this.getMeta().ui}},p0=class extends(globalThis.ScriptProcessorNode||null){constructor(){super(...arguments);this.handleDeviceMotion=void 0,this.handleDeviceOrientation=void 0}init(X){this.fDSPCode=X,this.fInputs=new Array(this.fDSPCode.getNumInputs()),this.fOutputs=new Array(this.fDSPCode.getNumOutputs()),this.handleDeviceMotion=({accelerationIncludingGravity:q})=>{const Q=/Android/i.test(navigator.userAgent);if(!q)return;const{x:Y,y:Z,z:U}=q;this.propagateAcc({x:Y,y:Z,z:U},Q)},this.handleDeviceOrientation=({alpha:q,beta:Q,gamma:Y})=>{this.propagateGyr({alpha:q,beta:Q,gamma:Y})},this.onaudioprocess=(q)=>{for(let Q=0;Q<this.fDSPCode.getNumInputs();Q++)this.fInputs[Q]=q.inputBuffer.getChannelData(Q);for(let Q=0;Q<this.fDSPCode.getNumOutputs();Q++)this.fOutputs[Q]=q.outputBuffer.getChannelData(Q);return this.fDSPCode.compute(this.fInputs,this.fOutputs)},this.start()}async startSensors(){if(this.hasAccInput)if(window.DeviceMotionEvent)if(typeof window.DeviceMotionEvent.requestPermission==="function")try{const X=await window.DeviceMotionEvent.requestPermission();if(X==="granted")window.addEventListener("devicemotion",this.handleDeviceMotion,!0);else if(X==="denied")throw alert("You have denied access to motion and orientation data. To enable it, go to Settings > Safari > Motion & Orientation Access."),new Error("Unable to access the accelerometer.")}catch(X){console.error(X)}else window.addEventListener("devicemotion",this.handleDeviceMotion,!0);else console.log("Cannot set the accelerometer handler.");if(this.hasGyrInput)if(window.DeviceMotionEvent)if(typeof window.DeviceOrientationEvent.requestPermission==="function")try{const X=await window.DeviceOrientationEvent.requestPermission();if(X==="granted")window.addEventListener("deviceorientation",this.handleDeviceOrientation,!0);else if(X==="denied")throw alert("You have denied access to motion and orientation data. To enable it, go to Settings > Safari > Motion & Orientation Access."),new Error("Unable to access the gyroscope.")}catch(X){console.error(X)}else window.addEventListener("deviceorientation",this.handleDeviceOrientation,!0);else console.log("Cannot set the gyroscope handler.")}stopSensors(){if(this.hasAccInput)window.removeEventListener("devicemotion",this.handleDeviceMotion,!0);if(this.hasGyrInput)window.removeEventListener("deviceorientation",this.handleDeviceOrientation,!0)}compute(X,q){return this.fDSPCode.compute(X,q)}setOutputParamHandler(X){this.fDSPCode.setOutputParamHandler(X)}getOutputParamHandler(){return this.fDSPCode.getOutputParamHandler()}setComputeHandler(X){this.fDSPCode.setComputeHandler(X)}getComputeHandler(){return this.fDSPCode.getComputeHandler()}setPlotHandler(X){this.fDSPCode.setPlotHandler(X)}getPlotHandler(){return this.fDSPCode.getPlotHandler()}getNumInputs(){return this.fDSPCode.getNumInputs()}getNumOutputs(){return this.fDSPCode.getNumOutputs()}metadata(X){}midiMessage(X){this.fDSPCode.midiMessage(X)}ctrlChange(X,q,Q){this.fDSPCode.ctrlChange(X,q,Q)}pitchWheel(X,q){this.fDSPCode.pitchWheel(X,q)}setParamValue(X,q){this.fDSPCode.setParamValue(X,q)}getParamValue(X){return this.fDSPCode.getParamValue(X)}getParams(){return this.fDSPCode.getParams()}getMeta(){return this.fDSPCode.getMeta()}getJSON(){return this.fDSPCode.getJSON()}getDescriptors(){return this.fDSPCode.getDescriptors()}getUI(){return this.fDSPCode.getUI()}start(){this.fDSPCode.start()}stop(){this.fDSPCode.stop()}destroy(){this.fDSPCode.destroy()}get hasAccInput(){return this.fDSPCode.hasAccInput}propagateAcc(X,q=!1){this.fDSPCode.propagateAcc(X,q)}get hasGyrInput(){return this.fDSPCode.hasGyrInput}propagateGyr(X){this.fDSPCode.propagateGyr(X)}},P1=class extends p0{},S1=class extends p0{keyOn(X,q,Q){this.fDSPCode.keyOn(X,q,Q)}keyOff(X,q,Q){this.fDSPCode.keyOff(X,q,Q)}allNotesOff(X){this.fDSPCode.allNotesOff(X)}},d0=class X{constructor(){this.factory=null}async compile(q,Q,Y,Z){if(this.factory=await q.createMonoDSPFactory(Q,Y,Z),this.factory)return this.name=Q,this;else return null}addSoundfiles(q){if(!this.factory)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");for(let Q in q)this.factory.soundfiles[Q]=q[Q]}getSoundfileList(){if(!this.factory)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");const q=JSON.parse(this.factory.json),Q=o.findSoundfilesFromMeta(q);return Object.keys(Q)}async createNode(q,Q=this.name,Y=this.factory,Z=!1,U=1024,J=(Y==null?void 0:Y.shaKey)||Q,K={}){var G,R;if(!Y)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");const V=JSON.parse(Y.json),E=V.compile_options.match("-double")?8:4;if(Y.soundfiles=await o.loadSoundfiles(V,Y.soundfiles||{},q),Z){const W=await d.createAsyncMonoDSPInstance(Y),L=new n(W,q.sampleRate,E,U,Y.soundfiles),M=q.createScriptProcessor(U,L.getNumInputs(),L.getNumOutputs());return Object.setPrototypeOf(M,P1.prototype),M.init(L),M}else{if(!X.gWorkletProcessors.has(q))X.gWorkletProcessors.set(q,new Set);if(!((G=X.gWorkletProcessors.get(q))==null?void 0:G.has(J)))try{const L=`
// DSP name and JSON string for DSP are generated
const faustData = ${JSON.stringify({processorName:J,dspName:Q,dspMeta:V,poly:!1})};
// Implementation needed classes of functions
var ${u.name} = ${u.toString()}
var FaustDspInstance = ${u.name};
var ${P.name} = ${P.toString()}
var FaustBaseWebAudioDsp = ${P.name};
var ${n.name} = ${n.toString()}
var FaustMonoWebAudioDsp = ${n.name};
var ${d.name} = ${d.toString()}
var FaustWasmInstantiator = ${d.name};
var ${f.name} = ${f.toString()}
var Soundfile = ${f.name};
var ${m.name} = ${m.toString()}
var WasmAllocator = ${m.name};
var ${l.name} = ${l.toString()}
var FaustSensors = ${l.name};
// Put them in dependencies
const dependencies = {
    FaustBaseWebAudioDsp,
    FaustMonoWebAudioDsp,
    FaustWasmInstantiator
};
// Generate the actual AudioWorkletProcessor code
(${K0.toString()})(dependencies, faustData);
`,M=URL.createObjectURL(new Blob([L],{type:"text/javascript"}));await q.audioWorklet.addModule(M),(R=X.gWorkletProcessors.get(q))==null||R.add(J)}catch(L){throw L}return new P0(q,{processorOptions:{name:J,factory:Y,sampleSize:E,...K}})}}async createFFTNode(q,Q,Y=this.name,Z=this.factory,U={},J=(Z==null?void 0:Z.shaKey)?`${Z.shaKey}_fft`:Y,K={}){var G,R;if(!Z)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");const V=JSON.parse(Z.json),E=V.compile_options.match("-double")?8:4;if(Z.soundfiles=await o.loadSoundfiles(V,Z.soundfiles||{},q),!X.gWorkletProcessors.has(q))X.gWorkletProcessors.set(q,new Set);if(!((G=X.gWorkletProcessors.get(q))==null?void 0:G.has(J)))try{const L=`
// DSP name and JSON string for DSP are generated
const faustData = ${JSON.stringify({processorName:J,dspName:Y,dspMeta:V,fftOptions:U})};
// Implementation needed classes of functions
var ${u.name} = ${u.toString()}
var FaustDspInstance = ${u.name};
var ${P.name} = ${P.toString()}
var FaustBaseWebAudioDsp = ${P.name};
var ${n.name} = ${n.toString()}
var FaustMonoWebAudioDsp = ${n.name};
var ${d.name} = ${d.toString()}
var FaustWasmInstantiator = ${d.name};
var ${f.name} = ${f.toString()}
var Soundfile = ${f.name};
var ${m.name} = ${m.toString()}
var WasmAllocator = ${m.name};
var ${l.name} = ${l.toString()}
var FaustSensors = ${l.name};
var FFTUtils = ${Q.toString()}
// Put them in dependencies
const dependencies = {
    FaustBaseWebAudioDsp,
    FaustMonoWebAudioDsp,
    FaustWasmInstantiator,
    FFTUtils
};
// Generate the actual AudioWorkletProcessor code
(${R1.toString()})(dependencies, faustData);
`,M=URL.createObjectURL(new Blob([L],{type:"text/javascript"}));await q.audioWorklet.addModule(M),(R=X.gWorkletProcessors.get(q))==null||R.add(J)}catch(L){throw L}const W=new P0(q,{channelCount:Math.max(1,Math.ceil(V.inputs/3)),outputChannelCount:[Math.ceil(V.outputs/2)],processorOptions:{name:J,factory:Z,sampleSize:E,...K}});if(U.fftSize){const L=W.parameters.get("fftSize");if(L)L.value=U.fftSize}if(U.fftOverlap){const L=W.parameters.get("fftOverlap");if(L)L.value=U.fftOverlap}if(typeof U.defaultWindowFunction==="number"){const L=W.parameters.get("windowFunction");if(L)L.value=U.defaultWindowFunction+1}if(typeof U.noIFFT==="boolean"){const L=W.parameters.get("noIFFT");if(L)L.value=+U.noIFFT}return W}async createAudioWorkletProcessor(q=this.name,Q=this.factory,Y=(Q==null?void 0:Q.shaKey)||q){if(!Q)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");const Z=JSON.parse(Q.json),U={FaustBaseWebAudioDsp:P,FaustMonoWebAudioDsp:n,FaustWasmInstantiator:d,FaustPolyWebAudioDsp:void 0,FaustWebAudioDspVoice:void 0};try{return K0(U,{processorName:Y,dspName:q,dspMeta:Z,poly:!1})}catch(J){throw J}}async createOfflineProcessor(q,Q,Y=this.factory,Z){if(!Y)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");const U=JSON.parse(Y.json),J=await d.createAsyncMonoDSPInstance(Y),K=U.compile_options.match("-double")?8:4;if(Z)Y.soundfiles=await o.loadSoundfiles(U,Y.soundfiles||{},Z);const G=new n(J,q,K,Q,Y.soundfiles);return new C1(G,Q)}getMeta(){return JSON.parse(this.factory.json)}getJSON(){return JSON.stringify(this.getMeta())}getUI(){return this.getMeta().ui}};d0.gWorkletProcessors=new Map;var l0=d0,g1=class X{constructor(){this.voiceFactory=null,this.effectFactory=null}async compile(q,Q,Y,Z,U=`dsp_code = environment{
                ${Y}
            };
            process = dsp_code.effect;`){try{if(this.effectFactory=await q.createPolyDSPFactory(Q,U,Z),this.effectFactory){const J=JSON.parse(this.effectFactory.json),K=`// Voice output is forced to 2, when DSP is stereo or effect has 2 ins or 2 outs,
// so that the effect can process the 2 channels of the voice
adaptOut(1,1,1) = _;
adaptOut(1,1,2) = _ <: _,0;  // The left channel only is kept
adaptOut(1,2,1) = _ <: _,_;
adaptOut(1,2,2) = _ <: _,_;
adaptOut(2,1,1) = _,_;
adaptOut(2,1,2) = _,_;
adaptOut(2,2,1) = _,_;
adaptOut(2,2,2) = _,_;
adaptor(F) = adaptOut(outputs(F),${J.inputs},${J.outputs});
dsp_code = environment{
    ${Y}
};
process = dsp_code.process : adaptor(dsp_code.process);
`,G=`// Inputs
adaptIn(1,1,1) = _;
adaptIn(1,1,2) = _,_ :> _;  
adaptIn(1,2,1) = _,_;
adaptIn(1,2,2) = _,_;
adaptIn(2,1,1) = _,_ :> _;
adaptIn(2,1,2) = _,_ :> _;
adaptIn(2,2,1) = _,_;
adaptIn(2,2,2) = _,_;
// Outputs
adaptOut(1,1) = _ <: _,0;   // The left channel only is kept
adaptOut(1,2) = _,_;
adaptOut(2,1) = _ <: _,0;   // The left channel only is kept
adaptOut(2,2) = _,_;
adaptorIns(F) = adaptIn(outputs(F),${J.inputs},${J.outputs});
adaptorOuts = adaptOut(${J.inputs},${J.outputs});
dsp_code = environment{
    ${Y}
};
process = adaptorIns(dsp_code.process) : dsp_code.effect : adaptorOuts;
`;this.voiceFactory=await q.createPolyDSPFactory(Q,K,Z);try{this.effectFactory=await q.createPolyDSPFactory(Q,G,Z+" -inpl")}catch(R){console.warn(R)}}}catch(J){console.warn(J),this.voiceFactory=await q.createPolyDSPFactory(Q,Y,Z)}if(this.voiceFactory){this.name=Q;const K=JSON.parse(this.voiceFactory.json).compile_options.match("-double"),{mixerBuffer:G,mixerModule:R}=await q.getAsyncInternalMixerModule(!!K);return this.mixerBuffer=G,this.mixerModule=R,this}else return null}addSoundfiles(q){if(!this.voiceFactory)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");for(let Q in q)this.voiceFactory.soundfiles[Q]=q[Q]}getSoundfileList(){if(!this.voiceFactory)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");const q=JSON.parse(this.voiceFactory.json),Q=o.findSoundfilesFromMeta(q);if(!this.effectFactory)return Object.keys(Q);const Y=JSON.parse(this.effectFactory.json),Z=o.findSoundfilesFromMeta(Y);return Object.keys({...Z,...Q})}async createNode(q,Q,Y=this.name,Z=this.voiceFactory,U=this.mixerModule,J=this.effectFactory,K=!1,G=1024,R=((Z==null?void 0:Z.shaKey)||"")+((J==null?void 0:J.shaKey)||"")||`${Y}_poly`,V={}){var E,W;if(!Z)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");const L=JSON.parse(Z.json),M=J?JSON.parse(J.json):void 0,F=L.compile_options.match("-double")?8:4;if(Z.soundfiles=await o.loadSoundfiles(L,Z.soundfiles||{},q),J)J.soundfiles=await o.loadSoundfiles(M,J.soundfiles||{},q);if(K){const z=await d.createAsyncPolyDSPInstance(Z,U,Q,J||void 0),g={...J==null?void 0:J.soundfiles,...Z.soundfiles},T=new e(z,q.sampleRate,F,G,g),B=q.createScriptProcessor(G,T.getNumInputs(),T.getNumOutputs());return Object.setPrototypeOf(B,S1.prototype),B.init(T),B}else{if(!X.gWorkletProcessors.has(q))X.gWorkletProcessors.set(q,new Set);if(!((E=X.gWorkletProcessors.get(q))==null?void 0:E.has(R)))try{const g=`
// DSP name and JSON string for DSP are generated
const faustData = ${JSON.stringify({processorName:R,dspName:Y,dspMeta:L,poly:!0,effectMeta:M})};
// Implementation needed classes of functions
var ${u.name} = ${u.toString()}
var FaustDspInstance = ${u.name};
var ${P.name} = ${P.toString()}
var FaustBaseWebAudioDsp = ${P.name};
var ${e.name} = ${e.toString()}
var FaustPolyWebAudioDsp = ${e.name};
var ${S.name} = ${S.toString()}
var FaustWebAudioDspVoice = ${S.name};
var ${d.name} = ${d.toString()}
var FaustWasmInstantiator = ${d.name};
var ${f.name} = ${f.toString()}
var Soundfile = ${f.name};
var ${m.name} = ${m.toString()}
var WasmAllocator = ${m.name};
var ${l.name} = ${l.toString()}
var FaustSensors = ${l.name};
// Put them in dependencies
const dependencies = {
    FaustBaseWebAudioDsp,
    FaustPolyWebAudioDsp,
    FaustWasmInstantiator
};
// Generate the actual AudioWorkletProcessor code
(${K0.toString()})(dependencies, faustData);
`,T=URL.createObjectURL(new Blob([g],{type:"text/javascript"}));await q.audioWorklet.addModule(T),(W=X.gWorkletProcessors.get(q))==null||W.add(R)}catch(g){throw g}return new w1(q,{processorOptions:{name:R,voiceFactory:Z,mixerModule:U,voices:Q,sampleSize:F,effectFactory:J||void 0,...V}})}}async createAudioWorkletProcessor(q=this.name,Q=this.voiceFactory,Y=this.effectFactory,Z=((Q==null?void 0:Q.shaKey)||"")+((Y==null?void 0:Y.shaKey)||"")||`${q}_poly`){if(!Q)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");const U=JSON.parse(Q.json),J=Y?JSON.parse(Y.json):void 0,K=U.compile_options.match("-double")?8:4;try{return K0({FaustBaseWebAudioDsp:P,FaustMonoWebAudioDsp:void 0,FaustWasmInstantiator:d,FaustPolyWebAudioDsp:e,FaustWebAudioDspVoice:S},{processorName:Z,dspName:q,dspMeta:U,poly:!0,effectMeta:J})}catch(G){throw G}}async createOfflineProcessor(q,Q,Y,Z=this.voiceFactory,U=this.mixerModule,J=this.effectFactory,K){if(!Z)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");const G=JSON.parse(Z.json),R=J?JSON.parse(J.json):void 0,V=await d.createAsyncPolyDSPInstance(Z,U,Y,J||void 0),E=G.compile_options.match("-double")?8:4;if(K){if(Z.soundfiles=await o.loadSoundfiles(G,Z.soundfiles||{},K),J)J.soundfiles=await o.loadSoundfiles(R,J.soundfiles||{},K)}const W={...J==null?void 0:J.soundfiles,...Z.soundfiles},L=new e(V,q,E,Q,W);return new M1(L,Q)}getMeta(){const q=this.voiceFactory?JSON.parse(this.voiceFactory.json):null,Q=this.effectFactory?JSON.parse(this.effectFactory.json):null,Y={...q};if(Q)Y.ui=[{type:"tgroup",label:"Sequencer",items:[{type:"vgroup",label:"Instrument",items:q.ui},{type:"vgroup",label:"Effect",items:Q.ui}]}];else Y.ui=[{type:"tgroup",label:"Polyphonic",items:[{type:"vgroup",label:"Voices",items:q.ui}]}];return Y}getJSON(){return JSON.stringify(this.getMeta())}getUI(){return this.getMeta().ui}};g1.gWorkletProcessors=new Map;var f0=globalThis;f0.window=globalThis;self.onmessage=async function(X){try{const q=X.data,Q=q.content,Y=q.target,Z=q.faustModuleUrl,U=q.filename,J=await g0(Z),K=new v0(J);f0.libFaust=K;const G=new F0(K),R=U.split("/").at(-1).split(".")[0].trim();if(Y=="cmajor"){if(!G.generateAuxFiles(R,Q,"-lang cmajor-hybrid -cn "+R+" -o foo.cmajor"))throw new Error("Ooops");self.postMessage(G.fs().readFile("foo.cmajor",{encoding:"utf8"}))}else{const V=new l0;await V.compile(G,R,Q,"-lang wasm-i -json -ct 1 -es 1 -mcd 16 -mdd 1024 -mdy 33 -single -ftz 2");const E=V.factory.code,W=JSON.parse(V.factory.json),L=btoa(String.fromCharCode(...E));console.log(W)}}catch(q){self.postMessage({error:q.message})}};

//# debugId=37C00D66DAFC5A6564756E2164756E21
//# sourceMappingURL=faust.worker.js.map
