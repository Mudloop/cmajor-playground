var s0=Object.create;var{getPrototypeOf:u0,defineProperty:Q0,getOwnPropertyNames:B0,getOwnPropertyDescriptor:c0}=Object,E0=Object.prototype.hasOwnProperty;var b1=(Q,q,U)=>{U=Q!=null?s0(u0(Q)):{};const X=q||!Q||!Q.__esModule?Q0(U,"default",{value:Q,enumerable:!0}):U;for(let Y of B0(Q))if(!E0.call(X,Y))Q0(X,Y,{get:()=>Q[Y],enumerable:!0});return X},N0=new WeakMap,h1=(Q)=>{var q=N0.get(Q),U;if(q)return q;if(q=Q0({},"__esModule",{value:!0}),Q&&typeof Q==="object"||typeof Q==="function")B0(Q).map((X)=>!E0.call(q,X)&&Q0(q,X,{get:()=>Q[X],enumerable:!(U=c0(Q,X))||U.enumerable}));return N0.set(Q,q),q},F1=(Q,q)=>()=>(q||Q((q={exports:{}}).exports,q),q.exports);var m0=(Q,q)=>{for(var U in q)Q0(Q,U,{get:q[U],enumerable:!0,configurable:!0,set:(X)=>q[U]=()=>X})};var r0=(Q,q)=>()=>(Q&&(q=Q(Q=0)),q);var n0=((Q)=>typeof require!=="undefined"?require:typeof Proxy!=="undefined"?new Proxy(Q,{get:(q,U)=>(typeof require!=="undefined"?require:q)[U]}):Q)(function(Q){if(typeof require!=="undefined")return require.apply(this,arguments);throw Error('Dynamic require of "'+Q+'" is not supported')});var C0={};m0(C0,{resolveObject:()=>A0,resolve:()=>M0,parse:()=>a,format:()=>I0,default:()=>Y1,Url:()=>u,URLSearchParams:()=>$0,URL:()=>L0});function W0(Q){return typeof Q=="string"}function O0(Q){return typeof Q=="object"&&Q!==null}function X0(Q){return Q===null}function o0(Q){return Q==null}function u(){this.protocol=null,this.slashes=null,this.auth=null,this.host=null,this.port=null,this.hostname=null,this.hash=null,this.search=null,this.query=null,this.pathname=null,this.path=null,this.href=null}function a(Q,q,U){if(Q&&O0(Q)&&Q instanceof u)return Q;var X=new u;return X.parse(Q,q,U),X}function I0(Q){return W0(Q)&&(Q=a(Q)),Q instanceof u?Q.format():u.prototype.format.call(Q)}function M0(Q,q){return a(Q,!1,!0).resolve(q)}function A0(Q,q){return Q?a(Q,!1,!0).resolveObject(q):q}var L0,$0,i0,t0,a0,e0,q1,G0,k0,j0,U1=255,H0,Q1,X1,T0,t,V0,Y1;var D0=r0(()=>{({URL:L0,URLSearchParams:$0}=globalThis),i0=/^([a-z0-9.+-]+:)/i,t0=/:[0-9]*$/,a0=/^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,e0=["<",">",'"',"`"," ","\r",`
`,"	"],q1=["{","}","|","\\","^","`"].concat(e0),G0=["'"].concat(q1),k0=["%","/","?",";","#"].concat(G0),j0=["/","?","#"],H0=/^[+a-z0-9A-Z_-]{0,63}$/,Q1=/^([+a-z0-9A-Z_-]{0,63})(.*)$/,X1={javascript:!0,"javascript:":!0},T0={javascript:!0,"javascript:":!0},t={http:!0,https:!0,ftp:!0,gopher:!0,file:!0,"http:":!0,"https:":!0,"ftp:":!0,"gopher:":!0,"file:":!0},V0={parse(Q){var q=decodeURIComponent;return(Q+"").replace(/\+/g," ").split("&").filter(Boolean).reduce(function(U,X,Y){var Z=X.split("="),J=q(Z[0]||""),K=q(Z[1]||""),G=U[J];return U[J]=G===void 0?K:[].concat(G,K),U},{})},stringify(Q){var q=encodeURIComponent;return Object.keys(Q||{}).reduce(function(U,X){return[].concat(Q[X]).forEach(function(Y){U.push(q(X)+"="+q(Y))}),U},[]).join("&").replace(/\s/g,"+")}};u.prototype.parse=function(Q,q,U){if(!W0(Q))throw new TypeError("Parameter 'url' must be a string, not "+typeof Q);var X=Q.indexOf("?"),Y=X!==-1&&X<Q.indexOf("#")?"?":"#",Z=Q.split(Y),J=/\\/g;Z[0]=Z[0].replace(J,"/"),Q=Z.join(Y);var K=Q;if(K=K.trim(),!U&&Q.split("#").length===1){var G=a0.exec(K);if(G)return this.path=K,this.href=K,this.pathname=G[1],G[2]?(this.search=G[2],q?this.query=V0.parse(this.search.substr(1)):this.query=this.search.substr(1)):q&&(this.search="",this.query={}),this}var R=i0.exec(K);if(R){R=R[0];var T=R.toLowerCase();this.protocol=T,K=K.substr(R.length)}if(U||R||K.match(/^\/\/[^@\/]+@[^@\/]+/)){var k=K.substr(0,2)==="//";k&&!(R&&T0[R])&&(K=K.substr(2),this.slashes=!0)}if(!T0[R]&&(k||R&&!t[R])){for(var W=-1,L=0;L<j0.length;L++){var D=K.indexOf(j0[L]);D!==-1&&(W===-1||D<W)&&(W=D)}var F,z;W===-1?z=K.lastIndexOf("@"):z=K.lastIndexOf("@",W),z!==-1&&(F=K.slice(0,z),K=K.slice(z+1),this.auth=decodeURIComponent(F)),W=-1;for(var L=0;L<k0.length;L++){var D=K.indexOf(k0[L]);D!==-1&&(W===-1||D<W)&&(W=D)}W===-1&&(W=K.length),this.host=K.slice(0,W),K=K.slice(W),this.parseHost(),this.hostname=this.hostname||"";var g=this.hostname[0]==="["&&this.hostname[this.hostname.length-1]==="]";if(!g)for(var V=this.hostname.split(/\./),L=0,B=V.length;L<B;L++){var I=V[L];if(!!I&&!I.match(H0)){for(var M="",A=0,b=I.length;A<b;A++)I.charCodeAt(A)>127?M+="x":M+=I[A];if(!M.match(H0)){var h=V.slice(0,L),x=V.slice(L+1),r=I.match(Q1);r&&(h.push(r[1]),x.unshift(r[2])),x.length&&(K="/"+x.join(".")+K),this.hostname=h.join(".");break}}}this.hostname.length>U1?this.hostname="":this.hostname=this.hostname.toLowerCase(),g||(this.hostname=new L0(`https://${this.hostname}`).hostname);var N=this.port?":"+this.port:"",j=this.hostname||"";this.host=j+N,this.href+=this.host,g&&(this.hostname=this.hostname.substr(1,this.hostname.length-2),K[0]!=="/"&&(K="/"+K))}if(!X1[T])for(var L=0,B=G0.length;L<B;L++){var E=G0[L];if(K.indexOf(E)!==-1){var H=encodeURIComponent(E);H===E&&(H=escape(E)),K=K.split(E).join(H)}}var $=K.indexOf("#");$!==-1&&(this.hash=K.substr($),K=K.slice(0,$));var O=K.indexOf("?");if(O!==-1?(this.search=K.substr(O),this.query=K.substr(O+1),q&&(this.query=V0.parse(this.query)),K=K.slice(0,O)):q&&(this.search="",this.query={}),K&&(this.pathname=K),t[T]&&this.hostname&&!this.pathname&&(this.pathname="/"),this.pathname||this.search){var N=this.pathname||"",w=this.search||"";this.path=N+w}return this.href=this.format(),this};u.prototype.format=function(){var Q=this.auth||"";Q&&(Q=encodeURIComponent(Q),Q=Q.replace(/%3A/i,":"),Q+="@");var q=this.protocol||"",U=this.pathname||"",X=this.hash||"",Y=!1,Z="";this.host?Y=Q+this.host:this.hostname&&(Y=Q+(this.hostname.indexOf(":")===-1?this.hostname:"["+this.hostname+"]"),this.port&&(Y+=":"+this.port)),this.query&&O0(this.query)&&Object.keys(this.query).length&&(Z=V0.stringify(this.query));var J=this.search||Z&&"?"+Z||"";return q&&q.substr(-1)!==":"&&(q+=":"),this.slashes||(!q||t[q])&&Y!==!1?(Y="//"+(Y||""),U&&U.charAt(0)!=="/"&&(U="/"+U)):Y||(Y=""),X&&X.charAt(0)!=="#"&&(X="#"+X),J&&J.charAt(0)!=="?"&&(J="?"+J),U=U.replace(/[?#]/g,function(K){return encodeURIComponent(K)}),J=J.replace("#","%23"),q+Y+U+J+X};u.prototype.resolve=function(Q){return this.resolveObject(a(Q,!1,!0)).format()};u.prototype.resolveObject=function(Q){if(W0(Q)){var q=new u;q.parse(Q,!1,!0),Q=q}for(var U=new u,X=Object.keys(this),Y=0;Y<X.length;Y++){var Z=X[Y];U[Z]=this[Z]}if(U.hash=Q.hash,Q.href==="")return U.href=U.format(),U;if(Q.slashes&&!Q.protocol){for(var J=Object.keys(Q),K=0;K<J.length;K++){var G=J[K];G!=="protocol"&&(U[G]=Q[G])}return t[U.protocol]&&U.hostname&&!U.pathname&&(U.path=U.pathname="/"),U.href=U.format(),U}if(Q.protocol&&Q.protocol!==U.protocol){if(!t[Q.protocol]){for(var R=Object.keys(Q),T=0;T<R.length;T++){var k=R[T];U[k]=Q[k]}return U.href=U.format(),U}if(U.protocol=Q.protocol,!Q.host&&!T0[Q.protocol]){for(var B=(Q.pathname||"").split("/");B.length&&!(Q.host=B.shift()););Q.host||(Q.host=""),Q.hostname||(Q.hostname=""),B[0]!==""&&B.unshift(""),B.length<2&&B.unshift(""),U.pathname=B.join("/")}else U.pathname=Q.pathname;if(U.search=Q.search,U.query=Q.query,U.host=Q.host||"",U.auth=Q.auth,U.hostname=Q.hostname||Q.host,U.port=Q.port,U.pathname||U.search){var W=U.pathname||"",L=U.search||"";U.path=W+L}return U.slashes=U.slashes||Q.slashes,U.href=U.format(),U}var D=U.pathname&&U.pathname.charAt(0)==="/",F=Q.host||Q.pathname&&Q.pathname.charAt(0)==="/",z=F||D||U.host&&Q.pathname,g=z,V=U.pathname&&U.pathname.split("/")||[],B=Q.pathname&&Q.pathname.split("/")||[],I=U.protocol&&!t[U.protocol];if(I&&(U.hostname="",U.port=null,U.host&&(V[0]===""?V[0]=U.host:V.unshift(U.host)),U.host="",Q.protocol&&(Q.hostname=null,Q.port=null,Q.host&&(B[0]===""?B[0]=Q.host:B.unshift(Q.host)),Q.host=null),z=z&&(B[0]===""||V[0]==="")),F)U.host=Q.host||Q.host===""?Q.host:U.host,U.hostname=Q.hostname||Q.hostname===""?Q.hostname:U.hostname,U.search=Q.search,U.query=Q.query,V=B;else if(B.length)V||(V=[]),V.pop(),V=V.concat(B),U.search=Q.search,U.query=Q.query;else if(!o0(Q.search)){if(I){U.hostname=U.host=V.shift();var M=U.host&&U.host.indexOf("@")>0?U.host.split("@"):!1;M&&(U.auth=M.shift(),U.host=U.hostname=M.shift())}return U.search=Q.search,U.query=Q.query,(!X0(U.pathname)||!X0(U.search))&&(U.path=(U.pathname?U.pathname:"")+(U.search?U.search:"")),U.href=U.format(),U}if(!V.length)return U.pathname=null,U.search?U.path="/"+U.search:U.path=null,U.href=U.format(),U;for(var A=V.slice(-1)[0],b=(U.host||Q.host||V.length>1)&&(A==="."||A==="..")||A==="",h=0,x=V.length;x>=0;x--)A=V[x],A==="."?V.splice(x,1):A===".."?(V.splice(x,1),h++):h&&(V.splice(x,1),h--);if(!z&&!g)for(;h--;h)V.unshift("..");z&&V[0]!==""&&(!V[0]||V[0].charAt(0)!=="/")&&V.unshift(""),b&&V.join("/").substr(-1)!=="/"&&V.push("");var r=V[0]===""||V[0]&&V[0].charAt(0)==="/";if(I){U.hostname=U.host=r?"":V.length?V.shift():"";var M=U.host&&U.host.indexOf("@")>0?U.host.split("@"):!1;M&&(U.auth=M.shift(),U.host=U.hostname=M.shift())}return z=z||U.host&&V.length,z&&!r&&V.unshift(""),V.length?U.pathname=V.join("/"):(U.pathname=null,U.path=null),(!X0(U.pathname)||!X0(U.search))&&(U.path=(U.pathname?U.pathname:"")+(U.search?U.search:"")),U.auth=Q.auth||U.auth,U.slashes=U.slashes||Q.slashes,U.href=U.format(),U};u.prototype.parseHost=function(){var Q=this.host,q=t0.exec(Q);q&&(q=q[0],q!==":"&&(this.port=q.substr(1)),Q=Q.substr(0,Q.length-q.length)),Q&&(this.hostname=Q)};Y1={parse:a,resolve:M0,resolveObject:A0,format:I0,Url:u,URL:L0,URLSearchParams:$0}});function G1(Q,q,U,X){function Y(Z){return Z instanceof U?Z:new U(function(J){J(Z)})}return new(U||(U=Promise))(function(Z,J){function K(T){try{R(X.next(T))}catch(k){J(k)}}function G(T){try{R(X.throw(T))}catch(k){J(k)}}function R(T){T.done?Z(T.value):Y(T.value).then(K,G)}R((X=X.apply(Q,q||[])).next())})}function T1(Q,q){var U={label:0,sent:function(){if(Z[0]&1)throw Z[1];return Z[1]},trys:[],ops:[]},X,Y,Z,J=Object.create((typeof Iterator==="function"?Iterator:Object).prototype);return J.next=K(0),J.throw=K(1),J.return=K(2),typeof Symbol==="function"&&(J[Symbol.iterator]=function(){return this}),J;function K(R){return function(T){return G([R,T])}}function G(R){if(X)throw new TypeError("Generator is already executing.");while(J&&(J=0,R[0]&&(U=0)),U)try{if(X=1,Y&&(Z=R[0]&2?Y.return:R[0]?Y.throw||((Z=Y.return)&&Z.call(Y),0):Y.next)&&!(Z=Z.call(Y,R[1])).done)return Z;if(Y=0,Z)R=[R[0]&2,Z.value];switch(R[0]){case 0:case 1:Z=R;break;case 4:return U.label++,{value:R[1],done:!1};case 5:U.label++,Y=R[1],R=[0];continue;case 7:R=U.ops.pop(),U.trys.pop();continue;default:if((Z=U.trys,!(Z=Z.length>0&&Z[Z.length-1]))&&(R[0]===6||R[0]===2)){U=0;continue}if(R[0]===3&&(!Z||R[1]>Z[0]&&R[1]<Z[3])){U.label=R[1];break}if(R[0]===6&&U.label<Z[1]){U.label=Z[1],Z=R;break}if(Z&&U.label<Z[2]){U.label=Z[2],U.ops.push(R);break}if(Z[2])U.ops.pop();U.trys.pop();continue}R=q.call(Q,U)}catch(T){R=[6,T],Y=0}finally{X=Z=0}if(R[0]&5)throw R[1];return{value:R[0]?R[1]:void 0,done:!0}}}function b0(Q){if(Q instanceof Uint8Array)return Q;if(typeof Q==="string")return E1(Q);if(ArrayBuffer.isView(Q))return new Uint8Array(Q.buffer,Q.byteOffset,Q.byteLength/Uint8Array.BYTES_PER_ELEMENT);return new Uint8Array(Q)}function k1(Q){if(typeof Q==="string")return Q.length===0;return Q.byteLength===0}function H1(Q){var q=b0(Q);if(q.byteLength>c){var U=new Y0;U.update(q),q=U.digest()}var X=new Uint8Array(c);return X.set(q),X}var S0=(Q,q,U)=>{if(!q.has(Q))throw TypeError("Cannot "+U)},z0=(Q,q,U)=>{return S0(Q,q,"read from private field"),U?U.call(Q):q.get(Q)},w0=(Q,q,U)=>{if(q.has(Q))throw TypeError("Cannot add the same private member more than once");q instanceof WeakSet?q.add(Q):q.set(Q,U)},_0=(Q,q,U,X)=>{return S0(Q,q,"write to private field"),X?X.call(Q,U):q.set(Q,U),U},Z1=async(Q,q=Q.replace(/c?js$/,"data"),U=Q.replace(/c?js$/,"wasm"))=>{var X,Y;let Z,J,K;const G=/var (.+) = \(/;if(typeof window==="object"){let T=await(await fetch(Q)).text();T=`${T}
export default ${(X=T.match(G))==null?void 0:X[1]};
`,Z=(await import(URL.createObjectURL(new Blob([T],{type:"text/javascript"})))).default,J=await(await fetch(q)).arrayBuffer(),K=new Uint8Array(await(await fetch(U)).arrayBuffer())}else{const{promises:T}=await import("fs"),{pathToFileURL:k}=await Promise.resolve().then(() => (D0(),C0));let W=await T.readFile(Q,{encoding:"utf-8"});W=`
import process from "process";
import * as path from "path";
import { createRequire } from "module";
import { fileURLToPath } from "url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const __filename = fileURLToPath(import.meta.url);
const require = createRequire(import.meta.url);

${W}

export default ${(Y=W.match(G))==null?void 0:Y[1]};
`;const L=Q.replace(/c?js$/,"mjs");await T.writeFile(L,W),Z=(await import(k(L).href)).default,await T.unlink(L),J=(await T.readFile(q)).buffer,K=(await T.readFile(U)).buffer}return await Z({wasmBinary:K,getPreloadedPackage:(T,k)=>{if(T==="libfaust-wasm.data")return J;return new ArrayBuffer(0)}})},g0=Z1,J1=(Q,q,U=!0)=>{const{registerProcessor:X,AudioWorkletProcessor:Y,sampleRate:Z}=globalThis,{FaustBaseWebAudioDsp:J,FaustWasmInstantiator:K}=Q,{processorName:G,dspName:R,dspMeta:T,effectMeta:k,poly:W}=q,L=(V)=>{const B=["/gate","/freq","/gain","/key","/vel","/velocity"],I="address"in V&&!!B.find((M)=>V.address.endsWith(M));if(W&&I)return null;if(V.type==="vslider"||V.type==="hslider"||V.type==="nentry")return{name:V.address,defaultValue:V.init||0,minValue:V.min||0,maxValue:V.max||0};else if(V.type==="button"||V.type==="checkbox")return{name:V.address,defaultValue:V.init||0,minValue:0,maxValue:1};return null};class D extends Y{constructor(V){super(V);this.paramValuesCache={},this.port.onmessage=(A)=>this.handleMessageAux(A);const{parameterDescriptors:B}=this.constructor;B.forEach((A)=>{this.paramValuesCache[A.name]=A.defaultValue||0});const{moduleId:I,instanceId:M}=V.processorOptions;if(!I||!M)return;this.wamInfo={moduleId:I,instanceId:M}}static get parameterDescriptors(){const V=[],B=(I)=>{const M=L(I);if(M)V.push(M)};if(J.parseUI(T.ui,B),k)J.parseUI(k.ui,B);return V}setupWamEventHandler(){var V;if(!this.wamInfo)return;const{moduleId:B,instanceId:I}=this.wamInfo,{webAudioModules:M}=globalThis,A=M.getModuleScope(B),b=(V=A==null?void 0:A.paramMgrProcessors)==null?void 0:V[I];if(!b)return;if(b.handleEvent)return;b.handleEvent=(h)=>{if(h.type==="wam-midi")this.midiMessage(h.data.bytes)}}process(V,B,I){for(let M in I){const[A]=I[M];if(A!==this.paramValuesCache[M])this.fDSPCode.setParamValue(M,A),this.paramValuesCache[M]=A}return this.fDSPCode.compute(V[0],B[0])}handleMessageAux(V){const B=V.data;switch(B.type){case"acc":{this.propagateAcc(B.data,B.invert);break}case"gyr":{this.propagateGyr(B.data);break}case"midi":{this.midiMessage(B.data);break}case"ctrlChange":{this.ctrlChange(B.data[0],B.data[1],B.data[2]);break}case"pitchWheel":{this.pitchWheel(B.data[0],B.data[1]);break}case"param":{this.setParamValue(B.data.path,B.data.value);break}case"setPlotHandler":{if(B.data)this.fDSPCode.setPlotHandler((I,M,A)=>this.port.postMessage({type:"plot",value:I,index:M,events:A}));else this.fDSPCode.setPlotHandler(null);break}case"setupWamEventHandler":{this.setupWamEventHandler();break}case"start":{this.fDSPCode.start();break}case"stop":{this.fDSPCode.stop();break}case"destroy":{this.port.close(),this.fDSPCode.destroy();break}default:break}}setParamValue(V,B){this.fDSPCode.setParamValue(V,B),this.paramValuesCache[V]=B}midiMessage(V){this.fDSPCode.midiMessage(V)}ctrlChange(V,B,I){this.fDSPCode.ctrlChange(V,B,I)}pitchWheel(V,B){this.fDSPCode.pitchWheel(V,B)}propagateAcc(V,B=!1){this.fDSPCode.propagateAcc(V,B)}propagateGyr(V){this.fDSPCode.propagateGyr(V)}}class F extends D{constructor(V){super(V);const{FaustMonoWebAudioDsp:B}=Q,{factory:I,sampleSize:M}=V.processorOptions,A=K.createSyncMonoDSPInstance(I);this.fDSPCode=new B(A,Z,M,128,I.soundfiles),this.fDSPCode.setOutputParamHandler((b,h)=>this.port.postMessage({path:b,value:h,type:"param"})),this.fDSPCode.start()}}class z extends D{constructor(V){super(V);this.handleMessageAux=(N)=>{const j=N.data;switch(j.type){case"keyOn":this.keyOn(j.data[0],j.data[1],j.data[2]);break;case"keyOff":this.keyOff(j.data[0],j.data[1],j.data[2]);break;default:super.handleMessageAux(N);break}};const{FaustPolyWebAudioDsp:B}=Q,{voiceFactory:I,mixerModule:M,voices:A,effectFactory:b,sampleSize:h}=V.processorOptions,x=K.createSyncPolyDSPInstance(I,M,A,b),r={...b==null?void 0:b.soundfiles,...I.soundfiles};this.fDSPCode=new B(x,Z,h,128,r),this.port.onmessage=(N)=>this.handleMessageAux(N),this.fDSPCode.setOutputParamHandler((N,j)=>this.port.postMessage({path:N,value:j,type:"param"})),this.fDSPCode.start()}midiMessage(V){const B=V[0]>>4,I=V[0]&15,M=V[1],A=V[2];if(B===8||B===9&&A===0)this.keyOff(I,M,A);else if(B===9)this.keyOn(I,M,A);else super.midiMessage(V)}keyOn(V,B,I){this.fDSPCode.keyOn(V,B,I)}keyOff(V,B,I){this.fDSPCode.keyOff(V,B,I)}allNotesOff(V){this.fDSPCode.allNotesOff(V)}}const g=W?z:F;if(U)try{X(G||R||(W?"mydsp_poly":"mydsp"),g)}catch(V){console.warn(V)}return W?z:F},K0=J1,K1=(Q,q,U=!0)=>{const{registerProcessor:X,AudioWorkletProcessor:Y,sampleRate:Z}=globalThis,{FaustBaseWebAudioDsp:J,FaustWasmInstantiator:K,FaustMonoWebAudioDsp:G,FFTUtils:R}=Q,{processorName:T,dspName:k,dspMeta:W,fftOptions:L}=q,{windowFunctions:D,getFFT:F,fftToSignal:z,signalToFFT:g,signalToNoFFT:V}=R,B=(N,j)=>Math.abs(j)<1?Math.ceil(N*(1/j))/(1/j):Math.ceil(N/j)*j,I=(N,j)=>(N%j+j)%j,M=(N,j)=>{for(let E=0;E<N.length;E++)N[E]*=j(E,N.length)},A=["/fftSize","/fftHopSize","/fftOverlap","/windowFunction","/noIFFT"],b=(N,j,E=0,H=0)=>{const $=N.length,O=j.length,w=Math.min($,O);let y=0,C=I(E,$)||0,_=I(H,O)||0;while(y<w){const v=Math.min(w-y,$-C,O-_),i=_+v;if(_===0&&i===O)N.set(j,C);else N.set(j.subarray(_,i),C);C=(C+v)%$,_=i%O,y+=v}return C},h=(N)=>{if("address"in N&&!!A.find((E)=>N.address.endsWith(E)))return null;if(N.type==="vslider"||N.type==="hslider"||N.type==="nentry")return{name:N.address,defaultValue:N.init||0,minValue:N.min||0,maxValue:N.max||0};else if(N.type==="button"||N.type==="checkbox")return{name:N.address,defaultValue:N.init||0,minValue:0,maxValue:1};return null};class x extends Y{constructor(N){super(N);this.paramValuesCache={},this.destroyed=!1,this.$inputWrite=0,this.$inputRead=0,this.$outputWrite=0,this.$outputRead=0,this.noIFFT=!1,this.fftInput=[],this.fftOutput=[],this.fftOverlap=0,this.fftHopSize=0,this.fftSize=0,this.fftBufferSize=0,this.fPlotHandler=null,this.fCachedEvents=[],this.fBufferNum=0,this.soundfiles={},this.windowFunction=null,this.port.onmessage=(w)=>this.handleMessageAux(w);const{parameterDescriptors:j}=this.constructor;j.forEach((w)=>{this.paramValuesCache[w.name]=w.defaultValue||0});const{factory:E,sampleSize:H}=N.processorOptions;this.dspInstance=K.createSyncMonoDSPInstance(E),this.sampleSize=H,this.soundfiles=E.soundfiles,this.initFFT();const{moduleId:$,instanceId:O}=N.processorOptions;if(!$||!O)return;this.wamInfo={moduleId:$,instanceId:O}}get fftProcessorBufferSize(){return this.fftSize/2+1}async initFFT(){return this.FFT=await F(),await this.createFFTProcessor(),!0}static get parameterDescriptors(){const N=[],j=(E)=>{const H=h(E);if(H)N.push(H)};return J.parseUI(W.ui,j),[...N,{defaultValue:(L==null?void 0:L.fftSize)||1024,maxValue:4294967296,minValue:2,name:"fftSize"},{defaultValue:(L==null?void 0:L.fftOverlap)||2,maxValue:32,minValue:1,name:"fftOverlap"},{defaultValue:typeof(L==null?void 0:L.defaultWindowFunction)==="number"?L.defaultWindowFunction+1:0,maxValue:(D==null?void 0:D.length)||0,minValue:0,name:"windowFunction"},{defaultValue:+!!(L==null?void 0:L.noIFFT)||0,maxValue:1,minValue:0,name:"noIFFT"}]}setupWamEventHandler(){var N;if(!this.wamInfo)return;const{moduleId:j,instanceId:E}=this.wamInfo,{webAudioModules:H}=globalThis,$=H.getModuleScope(j),O=(N=$==null?void 0:$.paramMgrProcessors)==null?void 0:N[E];if(!O)return;if(O.handleEvent)return;O.handleEvent=(w)=>{if(w.type==="wam-midi")this.midiMessage(w.data.bytes)}}processFFT(){let N=I(this.$inputWrite-this.$inputRead,this.fftBufferSize)||this.fftBufferSize;while(N>=this.fftSize){let j=[];this.fDSPCode.compute((E)=>{for(let H=0;H<Math.min(this.fftInput.length,Math.ceil(E.length/3));H++){const $=this.rfft.forward((O)=>{b(O,this.fftInput[H],0,this.$inputRead);for(let w=0;w<O.length;w++)O[w]*=this.window[w]});z($,E[H*3],E[H*3+1],E[H*3+2])}for(let H=this.fftInput.length*3;H<E.length;H++)if(H%3===2)E[H].forEach(($,O)=>E[H][O]=O);else E[H].fill(0)},(E)=>{j=E}),this.$inputRead+=this.fftHopSize,this.$inputRead%=this.fftBufferSize,N-=this.fftHopSize;for(let E=0;E<this.fftOutput.length;E++){let H;if(this.noIFFT)H=this.noIFFTBuffer,V(j[E*2]||this.fftProcessorZeros,j[E*2+1]||this.fftProcessorZeros,H);else H=this.rfft.inverse((O)=>{g(j[E*2]||this.fftProcessorZeros,j[E*2+1]||this.fftProcessorZeros,O)});for(let O=0;O<H.length;O++)H[O]*=this.window[O];let $;for(let O=0;O<H.length-this.fftHopSize;O++)if($=I(this.$outputWrite+O,this.fftBufferSize),this.fftOutput[E][$]+=H[O],E===0)this.windowSumSquare[$]+=this.noIFFT?this.window[O]:this.window[O]**2;for(let O=H.length-this.fftHopSize;O<H.length;O++)if($=I(this.$outputWrite+O,this.fftBufferSize),this.fftOutput[E][$]=H[O],E===0)this.windowSumSquare[$]=this.noIFFT?this.window[O]:this.window[O]**2}this.$outputWrite+=this.fftHopSize,this.$outputWrite%=this.fftBufferSize}}process(N,j,E){if(this.destroyed)return!1;if(!this.FFT)return!0;const H=N[0],$=j[0],O=(H==null?void 0:H.length)||0,w=($==null?void 0:$.length)||0,y=(H==null?void 0:H.length)?Math.max(...H.map((C)=>C.length))||128:128;if(this.noIFFT=!!E.noIFFT[0],this.resetFFT(~~E.fftSize[0],~~E.fftOverlap[0],~~E.windowFunction[0],O,w,y),!this.fDSPCode)return!0;for(let C in E){if(A.find((v)=>`/${C}`.endsWith(v)))continue;const[_]=E[C];if(_!==this.paramValuesCache[C])this.fDSPCode.setParamValue(C,_),this.paramValuesCache[C]=_}if(H==null?void 0:H.length){let C=0;for(let _=0;_<H.length;_++){const v=this.fftInput[_],i=H[_].length?H[_]:new Float32Array(y);C=b(v,i,this.$inputWrite)}this.$inputWrite=C}else this.$inputWrite+=y,this.$inputWrite%=this.fftBufferSize;this.processFFT();for(let C=0;C<$.length;C++){b($[C],this.fftOutput[C],0,this.$outputRead);let _=0;for(let v=0;v<y;v++)_=this.windowSumSquare[I(this.$outputRead+v,this.fftBufferSize)],$[C][v]/=_<0.00000001?1:_}if(this.$outputRead+=y,this.$outputRead%=this.fftBufferSize,this.fPlotHandler)this.port.postMessage({type:"plot",value:$,index:this.fBufferNum++,events:this.fCachedEvents}),this.fCachedEvents=[];return!0}handleMessageAux(N){var j,E,H;const $=N.data;switch($.type){case"midi":this.midiMessage($.data);break;case"ctrlChange":this.ctrlChange($.data[0],$.data[1],$.data[2]);break;case"pitchWheel":this.pitchWheel($.data[0],$.data[1]);break;case"param":this.setParamValue($.data.path,$.data.value);break;case"setPlotHandler":{if($.data)this.fPlotHandler=(O,w,y)=>{if(y)this.fCachedEvents.push(...y)};else this.fPlotHandler=null;(j=this.fDSPCode)==null||j.setPlotHandler(this.fPlotHandler);break}case"setupWamEventHandler":{this.setupWamEventHandler();break}case"start":{(E=this.fDSPCode)==null||E.start();break}case"stop":{(H=this.fDSPCode)==null||H.stop();break}case"destroy":{this.port.close(),this.destroy();break}default:break}}setParamValue(N,j){var E;(E=this.fDSPCode)==null||E.setParamValue(N,j),this.paramValuesCache[N]=j}midiMessage(N){var j;(j=this.fDSPCode)==null||j.midiMessage(N)}ctrlChange(N,j,E){var H;(H=this.fDSPCode)==null||H.ctrlChange(N,j,E)}pitchWheel(N,j){var E;(E=this.fDSPCode)==null||E.pitchWheel(N,j)}resetFFT(N,j,E,H,$,O){var w,y;const C=~~B(Math.max(2,N||1024),2),_=~~Math.min(C,Math.max(1,j)),v=~~Math.max(1,C/_),i=C-Math.min(v,O);let q0=null;if(E!==0)q0=typeof D==="object"?D[~~E-1]||null:null;const U0=C!==this.fftSize,R0=_!==this.fftOverlap;if(U0||R0){if(this.fftSize=C,this.fftOverlap=_,this.fftHopSize=v,this.$inputWrite=0,this.$inputRead=0,this.$outputWrite=0,this.$outputRead=-i,this.fftBufferSize=Math.max(C*2-this.fftHopSize,O*2),!U0&&this.fftHopSizeParam)(w=this.fDSPCode)==null||w.setParamValue(this.fftHopSizeParam,this.fftHopSize)}if(U0)(y=this.rfft)==null||y.dispose(),this.rfft=new this.FFT(C),this.noIFFTBuffer=new Float32Array(this.fftSize),this.createFFTProcessor();if(U0||R0||q0!==this.windowFunction){if(this.windowFunction=q0,this.window=new Float32Array(C),this.window.fill(1),q0)M(this.window,q0);this.windowSumSquare=new Float32Array(this.fftBufferSize)}if(this.fftInput.length>H)this.fftInput.splice(H);if(this.fftOutput.length>$)this.fftOutput.splice($);if(U0||R0){for(let p=0;p<H;p++)this.fftInput[p]=new Float32Array(this.fftBufferSize);for(let p=0;p<$;p++)this.fftOutput[p]=new Float32Array(this.fftBufferSize)}else{if(this.fftInput.length<H)for(let p=this.fftInput.length;p<H;p++)this.fftInput[p]=new Float32Array(this.fftBufferSize);if(this.fftOutput.length<$)for(let p=this.fftOutput.length;p<$;p++)this.fftOutput[p]=new Float32Array(this.fftBufferSize)}}async createFFTProcessor(){var N,j;(N=this.fDSPCode)==null||N.stop(),(j=this.fDSPCode)==null||j.destroy(),this.fDSPCode=new G(this.dspInstance,Z,this.sampleSize,this.fftProcessorBufferSize,this.soundfiles),this.fDSPCode.setOutputParamHandler(($,O)=>this.port.postMessage({path:$,value:O,type:"param"})),this.fDSPCode.setPlotHandler(this.fPlotHandler);const E=this.fDSPCode.getParams();this.fDSPCode.start();for(let $ in this.paramValuesCache){if(A.find((O)=>`/${$}`.endsWith(O)))continue;this.fDSPCode.setParamValue($,this.paramValuesCache[$])}const H=E.find(($)=>$.endsWith("/fftSize"));if(H)this.fDSPCode.setParamValue(H,this.fftSize);if(this.fftHopSizeParam=E.find(($)=>$.endsWith("/fftHopSize")),this.fftHopSizeParam)this.fDSPCode.setParamValue(this.fftHopSizeParam,this.fftHopSize);this.fftProcessorZeros=new Float32Array(this.fftProcessorBufferSize)}destroy(){var N,j,E;(N=this.fDSPCode)==null||N.stop(),(j=this.fDSPCode)==null||j.destroy(),(E=this.rfft)==null||E.dispose(),this.destroyed=!0}}const r=x;if(U)try{X(T||k||"myfftdsp",r)}catch(N){console.warn(N)}return x},R1=K1,c=64,V1=32,L1=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),W1=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225],N1=Math.pow(2,53)-1,Y0=function(){function Q(){this.state=Int32Array.from(W1),this.temp=new Int32Array(64),this.buffer=new Uint8Array(64),this.bufferLength=0,this.bytesHashed=0,this.finished=!1}return Q.prototype.update=function(q){if(this.finished)throw new Error("Attempted to update an already finished hash.");var U=0,X=q.byteLength;if(this.bytesHashed+=X,this.bytesHashed*8>N1)throw new Error("Cannot hash more than 2^53 - 1 bits");while(X>0)if(this.buffer[this.bufferLength++]=q[U++],X--,this.bufferLength===c)this.hashBuffer(),this.bufferLength=0},Q.prototype.digest=function(){if(!this.finished){var q=this.bytesHashed*8,U=new DataView(this.buffer.buffer,this.buffer.byteOffset,this.buffer.byteLength),X=this.bufferLength;if(U.setUint8(this.bufferLength++,128),X%c>=c-8){for(var Y=this.bufferLength;Y<c;Y++)U.setUint8(Y,0);this.hashBuffer(),this.bufferLength=0}for(var Y=this.bufferLength;Y<c-8;Y++)U.setUint8(Y,0);U.setUint32(c-8,Math.floor(q/4294967296),!0),U.setUint32(c-4,q),this.hashBuffer(),this.finished=!0}var Z=new Uint8Array(V1);for(var Y=0;Y<8;Y++)Z[Y*4]=this.state[Y]>>>24&255,Z[Y*4+1]=this.state[Y]>>>16&255,Z[Y*4+2]=this.state[Y]>>>8&255,Z[Y*4+3]=this.state[Y]>>>0&255;return Z},Q.prototype.hashBuffer=function(){var q=this,U=q.buffer,X=q.state,Y=X[0],Z=X[1],J=X[2],K=X[3],G=X[4],R=X[5],T=X[6],k=X[7];for(var W=0;W<c;W++){if(W<16)this.temp[W]=(U[W*4]&255)<<24|(U[W*4+1]&255)<<16|(U[W*4+2]&255)<<8|U[W*4+3]&255;else{var L=this.temp[W-2],D=(L>>>17|L<<15)^(L>>>19|L<<13)^L>>>10;L=this.temp[W-15];var F=(L>>>7|L<<25)^(L>>>18|L<<14)^L>>>3;this.temp[W]=(D+this.temp[W-7]|0)+(F+this.temp[W-16]|0)}var z=(((G>>>6|G<<26)^(G>>>11|G<<21)^(G>>>25|G<<7))+(G&R^~G&T)|0)+(k+(L1[W]+this.temp[W]|0)|0)|0,g=((Y>>>2|Y<<30)^(Y>>>13|Y<<19)^(Y>>>22|Y<<10))+(Y&Z^Y&J^Z&J)|0;k=T,T=R,R=G,G=K+z|0,K=J,J=Z,Z=Y,Y=z+g|0}X[0]+=Y,X[1]+=Z,X[2]+=J,X[3]+=K,X[4]+=G,X[5]+=R,X[6]+=T,X[7]+=k},Q}(),B1=(Q)=>new TextEncoder().encode(Q),E1=typeof Buffer!=="undefined"&&Buffer.from?function(Q){return Buffer.from(Q,"utf8")}:B1,j1=function(){function Q(q){this.secret=q,this.hash=new Y0,this.reset()}return Q.prototype.update=function(q){if(k1(q)||this.error)return;try{this.hash.update(b0(q))}catch(U){this.error=U}},Q.prototype.digestSync=function(){if(this.error)throw this.error;if(this.outer){if(!this.outer.finished)this.outer.update(this.hash.digest());return this.outer.digest()}return this.hash.digest()},Q.prototype.digest=function(){return G1(this,void 0,void 0,function(){return T1(this,function(q){return[2,this.digestSync()]})})},Q.prototype.reset=function(){if(this.hash=new Y0,this.secret){this.outer=new Y0;var q=H1(this.secret),U=new Uint8Array(c);U.set(q);for(var X=0;X<c;X++)q[X]^=54,U[X]^=92;this.hash.update(q),this.outer.update(U);for(var X=0;X<q.byteLength;X++)q[X]=0}},Q}(),$1=(Q)=>String.fromCharCode.apply(null,Q),O1=(Q)=>{const q=new ArrayBuffer(Q.length),U=new Uint8Array(q);for(let X=0,Y=Q.length;X<Y;X++)U[X]=Q.charCodeAt(X);return U},I1=async(Q)=>{const q=new j1;return q.update(Q),Array.from(await q.digest()).map((Y)=>Y.toString(16).padStart(2,"0")).join("")},h0=class Q{static serializeDSPFactories(){const q={};return this.gFactories.forEach((U,X)=>{const{code:Y,json:Z,poly:J}=U;q[X]={code:btoa($1(Y)),json:JSON.parse(Z),poly:J}}),q}static stringifyDSPFactories(){return JSON.stringify(this.serializeDSPFactories())}static deserializeDSPFactories(q){const U=[];for(let X in q){const Y=q[X],{code:Z,json:J,poly:K}=Y,G=O1(atob(Z));U.push(WebAssembly.compile(G).then((R)=>this.gFactories.set(X,{shaKey:X,cfactory:0,code:G,module:R,json:JSON.stringify(J),poly:K,soundfiles:{}})))}return Promise.all(U)}static importDSPFactories(q){const U=JSON.parse(q);return this.deserializeDSPFactories(U)}constructor(q){this.fLibFaust=q,this.fErrorMessage=""}intVec2intArray(q){const U=q.size(),X=new Uint8Array(U);for(let Y=0;Y<U;Y++)X[Y]=q.get(Y);return X}async createDSPFactory(q,U,X,Y){if(Q.gFactories.size>10)Q.gFactories.clear();let Z=await I1(q+U+X+(Y?"poly":"mono"));if(Q.gFactories.has(Z))return Q.gFactories.get(Z)||null;else try{const J=this.fLibFaust.createDSPFactory(q,U,X,!Y),K=this.intVec2intArray(J.data);J.data.delete();const G=await WebAssembly.compile(K),R={shaKey:Z,cfactory:J.cfactory,code:K,module:G,json:J.json,poly:Y,soundfiles:{}};return this.deleteDSPFactory(R),Q.gFactories.set(Z,R),R}catch(J){throw this.fErrorMessage=this.fLibFaust.getErrorAfterException(),this.fLibFaust.cleanupAfterException(),this.fErrorMessage?new Error(this.fErrorMessage):J}}version(){return this.fLibFaust.version()}getErrorMessage(){return this.fErrorMessage}async createMonoDSPFactory(q,U,X){return this.createDSPFactory(q,U,X,!1)}async createPolyDSPFactory(q,U,X){return this.createDSPFactory(q,U,X,!0)}deleteDSPFactory(q){this.fLibFaust.deleteDSPFactory(q.cfactory),q.cfactory=0}expandDSP(q,U){try{return this.fLibFaust.expandDSP("FaustDSP",q,U)}catch(X){throw this.fErrorMessage=this.fLibFaust.getErrorAfterException(),this.fLibFaust.cleanupAfterException(),this.fErrorMessage?new Error(this.fErrorMessage):X}}generateAuxFiles(q,U,X){try{return this.fLibFaust.generateAuxFiles(q,U,X)}catch(Y){throw this.fErrorMessage=this.fLibFaust.getErrorAfterException(),this.fLibFaust.cleanupAfterException(),this.fErrorMessage?new Error(this.fErrorMessage):Y}}deleteAllDSPFactories(){this.fLibFaust.deleteAllDSPFactories()}fs(){return this.fLibFaust.fs()}async getAsyncInternalMixerModule(q=!1){const U=q?"mixer64Buffer":"mixer32Buffer",X=q?"mixer64Module":"mixer32Module";if(this[X])return{mixerBuffer:this[U],mixerModule:this[X]};const Y=q?"/usr/rsrc/mixer64.wasm":"/usr/rsrc/mixer32.wasm",Z=this.fs().readFile(Y,{encoding:"binary"});this[U]=Z;const J=await WebAssembly.compile(Z);return this[X]=J,{mixerBuffer:Z,mixerModule:J}}getSyncInternalMixerModule(q=!1){const U=q?"mixer64Buffer":"mixer32Buffer",X=q?"mixer64Module":"mixer32Module";if(this[X])return{mixerBuffer:this[U],mixerModule:this[X]};const Y=q?"/usr/rsrc/mixer64.wasm":"/usr/rsrc/mixer32.wasm",Z=this.fs().readFile(Y,{encoding:"binary"});this[U]=Z;const J=new WebAssembly.Module(Z);return this[X]=J,{mixerBuffer:Z,mixerModule:J}}};h0.gFactories=new Map;var M1=h0,F0=M1,s=class{constructor(Q){this.fExports=Q}compute(Q,q,U,X){this.fExports.compute(Q,q,U,X)}getNumInputs(Q){return this.fExports.getNumInputs(Q)}getNumOutputs(Q){return this.fExports.getNumOutputs(Q)}getParamValue(Q,q){return this.fExports.getParamValue(Q,q)}getSampleRate(Q){return this.fExports.getSampleRate(Q)}init(Q,q){this.fExports.init(Q,q)}instanceClear(Q){this.fExports.instanceClear(Q)}instanceConstants(Q,q){this.fExports.instanceConstants(Q,q)}instanceInit(Q,q){this.fExports.instanceInit(Q,q)}instanceResetUserInterface(Q){this.fExports.instanceResetUserInterface(Q)}setParamValue(Q,q,U){this.fExports.setParamValue(Q,q,U)}},A1=class{static createWasmImport(Q){return{env:{memory:Q||new WebAssembly.Memory({initial:100}),memoryBase:0,tableBase:0,_abs:Math.abs,_acosf:Math.acos,_asinf:Math.asin,_atanf:Math.atan,_atan2f:Math.atan2,_ceilf:Math.ceil,_cosf:Math.cos,_expf:Math.exp,_floorf:Math.floor,_fmodf:(q,U)=>q%U,_logf:Math.log,_log10f:Math.log10,_max_f:Math.max,_min_f:Math.min,_remainderf:(q,U)=>q-Math.round(q/U)*U,_powf:Math.pow,_roundf:Math.round,_sinf:Math.sin,_sqrtf:Math.sqrt,_tanf:Math.tan,_acoshf:Math.acosh,_asinhf:Math.asinh,_atanhf:Math.atanh,_coshf:Math.cosh,_sinhf:Math.sinh,_tanhf:Math.tanh,_isnanf:Number.isNaN,_isinff:(q)=>!isFinite(q),_copysignf:(q,U)=>Math.sign(q)===Math.sign(U)?q:-q,_acos:Math.acos,_asin:Math.asin,_atan:Math.atan,_atan2:Math.atan2,_ceil:Math.ceil,_cos:Math.cos,_exp:Math.exp,_floor:Math.floor,_fmod:(q,U)=>q%U,_log:Math.log,_log10:Math.log10,_max_:Math.max,_min_:Math.min,_remainder:(q,U)=>q-Math.round(q/U)*U,_pow:Math.pow,_round:Math.round,_sin:Math.sin,_sqrt:Math.sqrt,_tan:Math.tan,_acosh:Math.acosh,_asinh:Math.asinh,_atanh:Math.atanh,_cosh:Math.cosh,_sinh:Math.sinh,_tanh:Math.tanh,_isnan:Number.isNaN,_isinf:(q)=>!isFinite(q),_copysign:(q,U)=>Math.sign(q)===Math.sign(U)?q:-q,table:new WebAssembly.Table({initial:0,element:"anyfunc"})}}}static createWasmMemoryPoly(Q,q,U,X,Y){const Z=Math.max(4,Q),J=q,K=(T)=>{let k=65536;while(k<T)k*=2;return k},G=X?X.size:0;let R=K(G+U.size*Z+(U.inputs+U.outputs*2)*(J+Y*q))/65536;return R=Math.max(2,R),new WebAssembly.Memory({initial:R})}static createWasmMemoryMono(Q,q,U){const X=Q,Y=(q.size+(q.inputs+q.outputs)*(X+U*Q))/65536;return new WebAssembly.Memory({initial:Y*2})}static createMonoDSPInstanceAux(Q,q,U=null){const X=Q.exports,Y=new s(X);return{memory:U?U:Q.exports.memory,api:Y,json:q}}static createMemoryMono(Q){const q=JSON.parse(Q.json),U=q.compile_options.match("-double")?8:4;return this.createWasmMemoryMono(U,q,8192)}static createMemoryPoly(Q,q,U){const X=JSON.parse(q.json),Y=U&&U.json?JSON.parse(U.json):null,Z=X.compile_options.match("-double")?8:4;return this.createWasmMemoryPoly(Q,Z,X,Y,8192)}static createMixerAux(Q,q){const U={imports:{print:console.log},memory:{memory:q}};return new WebAssembly.Instance(Q,U).exports}static async loadDSPFactory(Q,q){const U=await fetch(Q);if(!U.ok)throw new Error(`=> exception raised while running loadDSPFactory, file not found: ${Q}`);try{const X=await U.arrayBuffer(),Y=await WebAssembly.compile(X),J=await(await fetch(q)).text(),R=JSON.parse(J).compile_options.indexOf("wasm-e")!==-1;return{cfactory:0,code:new Uint8Array(X),module:Y,json:J,poly:R}}catch(X){throw X}}static async loadDSPMixer(Q,q){try{let U=null;if(q)U=q.readFile(Q,{encoding:"binary"});else U=await(await fetch(Q)).arrayBuffer();return WebAssembly.compile(U)}catch(U){throw U}}static async createAsyncMonoDSPInstance(Q){if(/"type":\s*"soundfile"/.test(Q.json)){const X=this.createMemoryMono(Q),Y=await WebAssembly.instantiate(Q.module,this.createWasmImport(X));return this.createMonoDSPInstanceAux(Y,Q.json,X)}else{const X=await WebAssembly.instantiate(Q.module,this.createWasmImport());return this.createMonoDSPInstanceAux(X,Q.json)}}static createSyncMonoDSPInstance(Q){if(/"type":\s*"soundfile"/.test(Q.json)){const X=this.createMemoryMono(Q),Y=new WebAssembly.Instance(Q.module,this.createWasmImport(X));return this.createMonoDSPInstanceAux(Y,Q.json,X)}else{const X=new WebAssembly.Instance(Q.module,this.createWasmImport());return this.createMonoDSPInstanceAux(X,Q.json)}}static async createAsyncPolyDSPInstance(Q,q,U,X){const Y=this.createMemoryPoly(U,Q,X),J=(await WebAssembly.instantiate(Q.module,this.createWasmImport(Y))).exports,K=new s(J),G=this.createMixerAux(q,Y);if(X){const T=(await WebAssembly.instantiate(X.module,this.createWasmImport(Y))).exports,k=new s(T);return{memory:Y,voices:U,voiceAPI:K,effectAPI:k,mixerAPI:G,voiceJSON:Q.json,effectJSON:X.json}}else return{memory:Y,voices:U,voiceAPI:K,mixerAPI:G,voiceJSON:Q.json}}static createSyncPolyDSPInstance(Q,q,U,X){const Y=this.createMemoryPoly(U,Q,X),J=new WebAssembly.Instance(Q.module,this.createWasmImport(Y)).exports,K=new s(J),G=this.createMixerAux(q,Y);if(X){const T=new WebAssembly.Instance(X.module,this.createWasmImport(Y)).exports,k=new s(T);return{memory:Y,voices:U,voiceAPI:K,effectAPI:k,mixerAPI:G,voiceJSON:Q.json,effectJSON:X.json}}else return{memory:Y,voices:U,voiceAPI:K,mixerAPI:G,voiceJSON:Q.json}}},d=A1,l=class Q{static convertToAxis(q){switch(q){case 0:return 0;case 1:return 1;case 2:return 2;default:return console.error("Error: Axis not found value: "+q),0}}static convertToCurve(q){switch(q){case 0:return 0;case 1:return 1;case 2:return 2;case 3:return 3;default:return console.error("Error: Curve not found value: "+q),0}}static get Range(){if(!this._Range)this._Range=class{constructor(q,U){this.fLo=Math.min(q,U),this.fHi=Math.max(q,U)}clip(q){if(q<this.fLo)return this.fLo;if(q>this.fHi)return this.fHi;return q}};return this._Range}static get Interpolator(){if(!this._Interpolator)this._Interpolator=class{constructor(q,U,X,Y){if(this.fRange=new Q.Range(q,U),U!==q)this.fCoef=(Y-X)/(U-q),this.fOffset=X-q*this.fCoef;else this.fCoef=0,this.fOffset=(X+Y)/2}returnMappedValue(q){var U=this.fRange.clip(q);return this.fOffset+U*this.fCoef}getLowHigh(q,U){return{amin:this.fRange.fLo,amax:this.fRange.fHi}}};return this._Interpolator}static get Interpolator3pt(){if(!this._Interpolator3pt)this._Interpolator3pt=class{constructor(q,U,X,Y,Z,J){this.fSegment1=new Q.Interpolator(q,U,Y,Z),this.fSegment2=new Q.Interpolator(U,X,Z,J),this.fMid=U}returnMappedValue(q){return q<this.fMid?this.fSegment1.returnMappedValue(q):this.fSegment2.returnMappedValue(q)}getMappingValues(q,U,X){var Y=this.fSegment1.getLowHigh(q,U),Z=this.fSegment2.getLowHigh(U,X);return{amin:Y.amin,amid:Z.amin,amax:Z.amax}}};return this._Interpolator3pt}static get UpConverter(){if(!this._UpConverter)this._UpConverter=class{constructor(q,U,X,Y,Z,J){this.fActive=!0,this.fA2F=new Q.Interpolator3pt(q,U,X,Y,Z,J),this.fF2A=new Q.Interpolator3pt(Y,Z,J,q,U,X)}uiToFaust(q){return this.fA2F.returnMappedValue(q)}faustToUi(q){return this.fF2A.returnMappedValue(q)}setMappingValues(q,U,X,Y,Z,J){this.fA2F=new Q.Interpolator3pt(q,U,X,Y,Z,J),this.fF2A=new Q.Interpolator3pt(Y,Z,J,q,U,X)}getMappingValues(q,U,X){return this.fA2F.getMappingValues(q,U,X)}setActive(q){this.fActive=q}getActive(){return this.fActive}};return this._UpConverter}static get DownConverter(){if(!this._DownConverter)this._DownConverter=class{constructor(q,U,X,Y,Z,J){this.fActive=!0,this.fA2F=new Q.Interpolator3pt(q,U,X,J,Z,Y),this.fF2A=new Q.Interpolator3pt(Y,Z,J,X,U,q)}uiToFaust(q){return this.fA2F.returnMappedValue(q)}faustToUi(q){return this.fF2A.returnMappedValue(q)}setMappingValues(q,U,X,Y,Z,J){this.fA2F=new Q.Interpolator3pt(q,U,X,J,Z,Y),this.fF2A=new Q.Interpolator3pt(Y,Z,J,X,U,q)}getMappingValues(q,U,X){return this.fA2F.getMappingValues(q,U,X)}setActive(q){this.fActive=q}getActive(){return this.fActive}};return this._DownConverter}static get UpDownConverter(){if(!this._UpDownConverter)this._UpDownConverter=class{constructor(q,U,X,Y,Z,J){this.fActive=!0,this.fA2F=new Q.Interpolator3pt(q,U,X,Y,J,Y),this.fF2A=new Q.Interpolator(Y,J,q,X)}uiToFaust(q){return this.fA2F.returnMappedValue(q)}faustToUi(q){return this.fF2A.returnMappedValue(q)}setMappingValues(q,U,X,Y,Z,J){this.fA2F=new Q.Interpolator3pt(q,U,X,Y,J,Y),this.fF2A=new Q.Interpolator(Y,J,q,X)}getMappingValues(q,U,X){return this.fA2F.getMappingValues(q,U,X)}setActive(q){this.fActive=q}getActive(){return this.fActive}};return this._UpDownConverter}static get DownUpConverter(){if(!this._DownUpConverter)this._DownUpConverter=class{constructor(q,U,X,Y,Z,J){this.fActive=!0,this.fA2F=new Q.Interpolator3pt(q,U,X,J,Y,J),this.fF2A=new Q.Interpolator(Y,J,q,X)}uiToFaust(q){return this.fA2F.returnMappedValue(q)}faustToUi(q){return this.fF2A.returnMappedValue(q)}setMappingValues(q,U,X,Y,Z,J){this.fA2F=new Q.Interpolator3pt(q,U,X,J,Y,J),this.fF2A=new Q.Interpolator(Y,J,q,X)}getMappingValues(q,U,X){return this.fA2F.getMappingValues(q,U,X)}setActive(q){this.fActive=q}getActive(){return this.fActive}};return this._DownUpConverter}static buildHandler(q,U,X,Y,Z,J,K){switch(q){case 0:return new Q.UpConverter(U,X,Y,Z,J,K);case 1:return new Q.DownConverter(U,X,Y,Z,J,K);case 2:return new Q.UpDownConverter(U,X,Y,Z,J,K);case 3:return new Q.DownUpConverter(U,X,Y,Z,J,K);default:return new Q.UpConverter(U,X,Y,Z,J,K)}}},m=class{constructor(Q,q){this.memory=Q,this.allocatedBytes=q}alloc(Q){const q=this.allocatedBytes,U=q+Q,X=this.memory.buffer.byteLength;if(U>X){const Y=Math.ceil((U-X)/65536);console.log(`GROW: ${Y} pages`),this.memory.grow(Y)}return this.allocatedBytes=U,q}getBuffer(){return this.memory.buffer}getInt32Array(){return new Int32Array(this.memory.buffer)}getInt64Array(){return new BigInt64Array(this.memory.buffer)}getFloat32Array(){return new Float32Array(this.memory.buffer)}getFloat64Array(){return new Float64Array(this.memory.buffer)}},f=class Q{static get MAX_SOUNDFILE_PARTS(){return 256}static get MAX_CHAN(){return 64}static get BUFFER_SIZE(){return 1024}static get SAMPLE_RATE(){return 44100}constructor(q,U,X,Y,Z,J){this.fSampleSize=U,this.fIntSize=this.fSampleSize,this.fPtrSize=4,this.fAllocator=q,console.log(`Soundfile constructor: curChan: ${X}, length: ${Y}, maxChan: ${Z}, totalParts: ${J}`),this.fPtr=q.alloc(4*this.fPtrSize),this.fLength=q.alloc(Q.MAX_SOUNDFILE_PARTS*this.fIntSize),this.fSR=q.alloc(Q.MAX_SOUNDFILE_PARTS*this.fIntSize),this.fOffset=q.alloc(Q.MAX_SOUNDFILE_PARTS*this.fIntSize),this.fBuffers=this.allocBuffers(X,Y,Z);const K=this.fAllocator.getInt32Array();K[this.fPtr>>2]=this.fBuffers,K[this.fPtr+this.fPtrSize>>2]=this.fLength,K[this.fPtr+2*this.fPtrSize>>2]=this.fSR,K[this.fPtr+3*this.fPtrSize>>2]=this.fOffset;for(let G=0;G<X;G++){const R=K[(this.fBuffers>>2)+G];console.log(`allocBuffers AFTER: ${G} - ${R}`)}}allocBuffers(q,U,X){const Y=this.fAllocator.alloc(X*this.fPtrSize);console.log(`allocBuffers buffers: ${Y}`);for(let Z=0;Z<q;Z++){const J=this.fAllocator.alloc(U*this.fSampleSize),K=this.fAllocator.getInt32Array();K[(Y>>2)+Z]=J}return Y}shareBuffers(q,U){const X=this.fAllocator.getInt32Array();for(let Y=q;Y<U;Y++)X[(this.fBuffers>>2)+Y]=X[(this.fBuffers>>2)+Y%q]}copyToOut(q,U,X,Y){if(this.fIntSize===4){const Z=this.fAllocator.getInt32Array();Z[(this.fLength>>Math.log2(this.fIntSize))+q]=Y.audioBuffer[0].length,Z[(this.fSR>>Math.log2(this.fIntSize))+q]=Y.sampleRate,Z[(this.fOffset>>Math.log2(this.fIntSize))+q]=X}else{const Z=this.fAllocator.getInt64Array();Z[(this.fLength>>Math.log2(this.fIntSize))+q]=BigInt(Y.audioBuffer[0].length),Z[(this.fSR>>Math.log2(this.fIntSize))+q]=BigInt(Y.sampleRate),Z[(this.fOffset>>Math.log2(this.fIntSize))+q]=BigInt(X)}if(console.log(`copyToOut: part: ${q}, maxChannels: ${U}, offset: ${X}, buffer: ${Y}`),this.fSampleSize===8)this.copyToOutReal64(U,X,Y);else this.copyToOutReal32(U,X,Y)}copyToOutReal32(q,U,X){const Y=this.fAllocator.getInt32Array(),Z=this.fAllocator.getFloat32Array();for(let J=0;J<X.audioBuffer.length;J++){const K=X.audioBuffer[J],G=Y[(this.fBuffers>>2)+J],R=G+U*this.fSampleSize>>Math.log2(this.fSampleSize),T=G+(U+K.length)*this.fSampleSize>>Math.log2(this.fSampleSize);console.log(`copyToOutReal32 begin: ${R}, end: ${T}, delta: ${T-R}`);const k=Z.subarray(G+U*this.fSampleSize>>Math.log2(this.fSampleSize),G+(U+K.length)*this.fSampleSize>>Math.log2(this.fSampleSize));for(let W=0;W<K.length;W++)k[W]=K[W]}}copyToOutReal64(q,U,X){const Y=this.fAllocator.getInt32Array(),Z=this.fAllocator.getFloat64Array();for(let J=0;J<X.audioBuffer.length;J++){const K=X.audioBuffer[J],G=Y[(this.fBuffers>>2)+J],R=G+U*this.fSampleSize>>Math.log2(this.fSampleSize),T=G+(U+K.length)*this.fSampleSize>>Math.log2(this.fSampleSize);console.log(`copyToOutReal64 begin: ${R}, end: ${T}, delta: ${T-R}`);const k=Z.subarray(G+U*this.fSampleSize>>Math.log2(this.fSampleSize),G+(U+K.length)*this.fSampleSize>>Math.log2(this.fSampleSize));for(let W=0;W<K.length;W++)k[W]=K[W]}}emptyFile(q,U){if(this.fIntSize===4){const X=this.fAllocator.getInt32Array();X[(this.fLength>>Math.log2(this.fIntSize))+q]=Q.BUFFER_SIZE,X[(this.fSR>>Math.log2(this.fIntSize))+q]=Q.SAMPLE_RATE,X[(this.fOffset>>Math.log2(this.fIntSize))+q]=U}else{const X=this.fAllocator.getInt64Array();X[(this.fLength>>Math.log2(this.fIntSize))+q]=BigInt(Q.BUFFER_SIZE),X[(this.fSR>>Math.log2(this.fIntSize))+q]=BigInt(Q.SAMPLE_RATE),X[(this.fOffset>>Math.log2(this.fIntSize))+q]=BigInt(U)}return U+Q.BUFFER_SIZE}displayMemory(q="",U=!1){console.log("Soundfile memory: "+q),console.log(`fPtr: ${this.fPtr}`),console.log(`fBuffers: ${this.fBuffers}`),console.log(`fLength: ${this.fLength}`),console.log(`fSR: ${this.fSR}`),console.log(`fOffset: ${this.fOffset}`);const X=this.fAllocator.getInt32Array();if(U)console.log(`HEAP32: ${X}`);console.log(`HEAP32[this.fPtr >> 2]: ${X[this.fPtr>>2]}`),console.log(`HEAP32[(this.fPtr + ptrSize) >> 2]: ${X[this.fPtr+this.fPtrSize>>2]}`),console.log(`HEAP32[(this.fPtr + 2 * ptrSize) >> 2]: ${X[this.fPtr+2*this.fPtrSize>>2]}`),console.log(`HEAP32[(this.fPtr + 3 * ptrSize) >> 2]: ${X[this.fPtr+3*this.fPtrSize>>2]}`)}getPtr(){return this.fPtr}getHEAP32(){return this.fAllocator.getInt32Array()}getHEAPFloat32(){return this.fAllocator.getFloat32Array()}getHEAPFloat64(){return this.fAllocator.getFloat64Array()}},P=class Q{constructor(q,U,X){this.fOutputHandler=null,this.fComputeHandler=null,this.fPlotHandler=null,this.fCachedEvents=[],this.fBufferNum=0,this.fInChannels=[],this.fOutChannels=[],this.fOutputsTimer=5,this.fInputsItems=[],this.fOutputsItems=[],this.fDescriptor=[],this.fSoundfiles=[],this.fSoundfileBuffers={},this.fPitchwheelLabel=[],this.fCtrlLabel=new Array(128).fill(null).map(()=>[]),this.fPathTable={},this.fUICallback=(Y)=>{if(Y.type==="hbargraph"||Y.type==="vbargraph")this.fOutputsItems.push(Y.address),this.fPathTable[Y.address]=Y.index;else if(Y.type==="vslider"||Y.type==="hslider"||Y.type==="button"||Y.type==="checkbox"||Y.type==="nentry"){if(this.fInputsItems.push(Y.address),this.fPathTable[Y.address]=Y.index,this.fDescriptor.push(Y),!Y.meta)return;Y.meta.forEach((Z)=>{const{midi:J,acc:K,gyr:G}=Z;if(J){const R=J.trim();if(R==="pitchwheel"){const T=R.match(/^pitchwheel\s(\d+)/);if(T)this.fPitchwheelLabel.push({path:Y.address,chan:parseInt(T[1]),min:Y.min,max:Y.max});else this.fPitchwheelLabel.push({path:Y.address,chan:0,min:Y.min,max:Y.max})}else{const T=R.match(/^ctrl\s(\d+)\s(\d+)/),k=R.match(/^ctrl\s(\d+)/);if(T)this.fCtrlLabel[parseInt(T[1])].push({path:Y.address,chan:parseInt(T[2]),min:Y.min,max:Y.max});else if(k)this.fCtrlLabel[parseInt(k[1])].push({path:Y.address,chan:0,min:Y.min,max:Y.max})}}if(K){const R=K.trim().split(" ").map(Number);this.setupAccHandler(Y.address,l.convertToAxis(R[0]),l.convertToCurve(R[1]),R[2],R[3],R[4],Y.min,Y.init,Y.max)}if(G){const R=G.trim().split(" ").map(Number);this.setupGyrHandler(Y.address,l.convertToAxis(R[0]),l.convertToCurve(R[1]),R[2],R[3],R[4],Y.min,Y.init,Y.max)}})}else if(Y.type==="soundfile")this.fSoundfiles.push({name:Y.label,url:Y.url,index:Y.index,basePtr:-1})},this.fProcessing=!1,this.fDestroyed=!1,this.fFirstCall=!0,this.fBufferSize=U,this.fPtrSize=q,this.fSampleSize=q,this.fSoundfileBuffers=X,this.fAcc={x:[],y:[],z:[]},this.fGyr={x:[],y:[],z:[]}}static remap(q,U,X,Y,Z){return(q-U)/(X-U)*(Z-Y)+Y}static parseUI(q,U){q.forEach((X)=>this.parseGroup(X,U))}static parseGroup(q,U){if(q.items)this.parseItems(q.items,U)}static parseItems(q,U){q.forEach((X)=>this.parseItem(X,U))}static parseItem(q,U){if(q.type==="vgroup"||q.type==="hgroup"||q.type==="tgroup")this.parseItems(q.items,U);else U(q)}static splitSoundfileNames(q){return q.replace(/^\{|\}$/g,"").split(";").map((X)=>X.length<=2?"":X.substring(1,X.length-1))}get hasAccInput(){return this.fAcc.x.length+this.fAcc.y.length+this.fAcc.z.length>0}propagateAcc(q,U=!1){const{x:X,y:Y,z:Z}=q;if(U){if(X!==null)this.fAcc.x.forEach((J)=>J(-X));if(Y!==null)this.fAcc.y.forEach((J)=>J(-Y));if(Z!==null)this.fAcc.z.forEach((J)=>J(-Z))}else{if(X!==null)this.fAcc.x.forEach((J)=>J(X));if(Y!==null)this.fAcc.y.forEach((J)=>J(Y));if(Z!==null)this.fAcc.z.forEach((J)=>J(Z))}}get hasGyrInput(){return this.fGyr.x.length+this.fGyr.y.length+this.fGyr.z.length>0}propagateGyr(q){const{alpha:U,beta:X,gamma:Y}=q;if(U!==null)this.fGyr.x.forEach((Z)=>Z(U));if(X!==null)this.fGyr.y.forEach((Z)=>Z(X));if(Y!==null)this.fGyr.z.forEach((Z)=>Z(Y))}setupAccHandler(q,U,X,Y,Z,J,K,G,R){const T=l.buildHandler(X,Y,Z,J,K,G,R);switch(U){case 0:this.fAcc.x.push((k)=>this.setParamValue(q,T.uiToFaust(k)));break;case 1:this.fAcc.y.push((k)=>this.setParamValue(q,T.uiToFaust(k)));break;case 2:this.fAcc.z.push((k)=>this.setParamValue(q,T.uiToFaust(k)));break}}setupGyrHandler(q,U,X,Y,Z,J,K,G,R){const T=l.buildHandler(X,Y,Z,J,K,G,R);switch(U){case 0:this.fGyr.x.push((k)=>this.setParamValue(q,T.uiToFaust(k)));break;case 1:this.fGyr.y.push((k)=>this.setParamValue(q,T.uiToFaust(k)));break;case 2:this.fGyr.z.push((k)=>this.setParamValue(q,T.uiToFaust(k)));break}}static extractUrlsFromMeta(q){const U=q.meta.find((X)=>X.soundfiles!==void 0);if(U)return U.soundfiles.split(";").filter((X)=>X!=="");else return[]}loadSoundfile(q,U,X,Y){console.log(`Soundfile ${X} paths: ${Y}`);const Z=Q.splitSoundfileNames(Y),J=this.fSoundfiles.find((K)=>K.url===Y);if(!J)throw new Error(`Soundfile with ${Y} cannot be found !}`);if(J.basePtr!==-1){const K=q.getInt32Array();console.log(`Soundfile CACHE ${Y}} : ${X} loaded at ${J.basePtr} in wasm memory with index ${J.index}`),K[U+J.index>>2]=J.basePtr}else{const K=this.createSoundfile(q,Z,this.fSoundfileBuffers);if(K){const G=K.getHEAP32();J.basePtr=K.getPtr(),console.log(`Soundfile ${X} loaded at ${J.basePtr} in wasm memory with index ${J.index}`),G[U+J.index>>2]=J.basePtr}else console.log(`Soundfile ${X} for ${Y} cannot be created !}`)}}createSoundfile(q,U,X,Y=f.MAX_CHAN){let Z=1,J=0;for(let R of U){let T=0,k=0;const W=X[R];if(W)T=W.audioBuffer.length,k=W.audioBuffer[0].length;else k=f.BUFFER_SIZE,T=1;Z=Math.max(Z,T),J+=k}J+=(f.MAX_SOUNDFILE_PARTS-U.length)*f.BUFFER_SIZE;const K=new f(q,this.fSampleSize,Z,J,Y,U.length);let G=0;for(let R=0;R<U.length;R++){const T=U[R],k=X[T];if(k)K.copyToOut(R,Y,G,k),G+=k.audioBuffer[0].length;else G=K.emptyFile(R,G)}for(let R=U.length;R<f.MAX_SOUNDFILE_PARTS;R++)G=K.emptyFile(R,G);return K.shareBuffers(Z,Y),K}initSoundfileMemory(q,U){for(let{name:X,url:Y}of this.fSoundfiles)this.loadSoundfile(q,U,X,Y)}updateOutputs(){if(this.fOutputsItems.length>0&&this.fOutputHandler&&this.fOutputsTimer--===0)this.fOutputsTimer=5,this.fOutputsItems.forEach((q)=>{var U;return(U=this.fOutputHandler)==null?void 0:U.call(this,q,this.getParamValue(q))})}metadata(q){if(this.fJSONDsp.meta)this.fJSONDsp.meta.forEach((U)=>q(Object.keys(U)[0],U[Object.keys(U)[0]]))}compute(q,U){return!1}setOutputParamHandler(q){this.fOutputHandler=q}getOutputParamHandler(){return this.fOutputHandler}setComputeHandler(q){this.fComputeHandler=q}getComputeHandler(){return this.fComputeHandler}setPlotHandler(q){this.fPlotHandler=q}getPlotHandler(){return this.fPlotHandler}getNumInputs(){return-1}getNumOutputs(){return-1}midiMessage(q){if(this.fPlotHandler)this.fCachedEvents.push({data:q,type:"midi"});const U=q[0]>>4,X=q[0]&15,Y=q[1],Z=q[2];if(U===11)return this.ctrlChange(X,Y,Z);if(U===14)return this.pitchWheel(X,Z*128+Y)}ctrlChange(q,U,X){if(this.fPlotHandler)this.fCachedEvents.push({type:"ctrlChange",data:[q,U,X]});if(this.fCtrlLabel[U].length)this.fCtrlLabel[U].forEach((Y)=>{const{path:Z,chan:J}=Y;if(J===0||q===J-1){if(this.setParamValue(Z,Q.remap(X,0,127,Y.min,Y.max)),this.fOutputHandler)this.fOutputHandler(Z,this.getParamValue(Z))}})}pitchWheel(q,U){if(this.fPlotHandler)this.fCachedEvents.push({type:"pitchWheel",data:[q,U]});this.fPitchwheelLabel.forEach((X)=>{const{path:Y,chan:Z}=X;if(Z===0||q===Z-1){if(this.setParamValue(Y,Q.remap(U,0,16383,X.min,X.max)),this.fOutputHandler)this.fOutputHandler(Y,this.getParamValue(Y))}})}setParamValue(q,U){}getParamValue(q){return 0}getParams(){return this.fInputsItems}getMeta(){return this.fJSONDsp}getJSON(){return JSON.stringify(this.getMeta())}getUI(){return this.fJSONDsp.ui}getDescriptors(){return this.fDescriptor}hasSoundfiles(){return this.fSoundfiles.length>0}start(){this.fProcessing=!0}stop(){this.fProcessing=!1}destroy(){this.fDestroyed=!0,this.fOutputHandler=null,this.fComputeHandler=null,this.fPlotHandler=null}},n=class extends P{constructor(Q,q,U,X,Y){super(U,X,Y);if(this.fInstance=Q,console.log(`sampleSize: ${U} bufferSize: ${X}`),this.fJSONDsp=JSON.parse(this.fInstance.json),P.parseUI(this.fJSONDsp.ui,this.fUICallback),this.fEndMemory=this.initMemory(),this.fInstance.api.init(this.fDSP,q),this.fSoundfiles.length>0){const Z=new m(this.fInstance.memory,this.fEndMemory);this.initSoundfileMemory(Z,this.fDSP)}}initMemory(){this.fDSP=0;const Q=this.fJSONDsp.size;this.fAudioInputs=Q,this.fAudioOutputs=this.fAudioInputs+this.getNumInputs()*this.fPtrSize;const q=this.fAudioOutputs+this.getNumOutputs()*this.fPtrSize,U=q+this.getNumInputs()*this.fBufferSize*this.fSampleSize,X=U+this.getNumOutputs()*this.fBufferSize*this.fSampleSize,Y=this.fInstance.memory.buffer,Z=new Int32Array(Y),J=this.fSampleSize===4?new Float32Array(Y):new Float64Array(Y);if(this.getNumInputs()>0){for(let G=0;G<this.getNumInputs();G++)Z[(this.fAudioInputs>>2)+G]=q+this.fBufferSize*this.fSampleSize*G;const K=Z.subarray(this.fAudioInputs>>2,this.fAudioInputs+this.getNumInputs()*this.fPtrSize>>2);for(let G=0;G<this.getNumInputs();G++)this.fInChannels[G]=J.subarray(K[G]>>Math.log2(this.fSampleSize),K[G]+this.fBufferSize*this.fSampleSize>>Math.log2(this.fSampleSize))}if(this.getNumOutputs()>0){for(let G=0;G<this.getNumOutputs();G++)Z[(this.fAudioOutputs>>2)+G]=U+this.fBufferSize*this.fSampleSize*G;const K=Z.subarray(this.fAudioOutputs>>2,this.fAudioOutputs+this.getNumOutputs()*this.fPtrSize>>2);for(let G=0;G<this.getNumOutputs();G++)this.fOutChannels[G]=J.subarray(K[G]>>Math.log2(this.fSampleSize),K[G]+this.fBufferSize*this.fSampleSize>>Math.log2(this.fSampleSize))}return X}toString(){return`============== Mono Memory layout ==============
        this.fBufferSize: ${this.fBufferSize}
        this.fJSONDsp.size: ${this.fJSONDsp.size}
        this.fAudioInputs: ${this.fAudioInputs}
        this.fAudioOutputs: ${this.fAudioOutputs}
        this.fDSP: ${this.fDSP}`}compute(Q,q){if(this.fDestroyed)return!1;if(!this.fProcessing)return!0;if(this.fFirstCall)this.initMemory(),this.fFirstCall=!1;if(typeof Q==="function")Q(this.fInChannels);else{if(this.getNumInputs()>0&&(!Q||!Q[0]||Q[0].length===0))return!0;if(this.getNumOutputs()>0&&typeof q!=="function"&&(!q||!q[0]||q[0].length===0))return!0;if(Q!==void 0)for(let X=0;X<Math.min(this.getNumInputs(),Q.length);X++)this.fInChannels[X].set(Q[X])}if(this.fComputeHandler)this.fComputeHandler(this.fBufferSize);this.fInstance.api.compute(this.fDSP,this.fBufferSize,this.fAudioInputs,this.fAudioOutputs),this.updateOutputs();let U=this.fOutChannels;if(typeof q==="function")q(this.fOutChannels);else{for(let X=0;X<Math.min(this.getNumOutputs(),q.length);X++){const Y=this.fOutChannels[X];q[X].set(Y)}U=q}if(this.fPlotHandler)this.fPlotHandler(U,this.fBufferNum++,this.fCachedEvents.length?this.fCachedEvents:void 0),this.fCachedEvents=[];return!0}metadata(Q){super.metadata(Q)}getNumInputs(){return this.fInstance.api.getNumInputs(this.fDSP)}getNumOutputs(){return this.fInstance.api.getNumOutputs(this.fDSP)}setParamValue(Q,q){if(this.fPlotHandler)this.fCachedEvents.push({type:"param",data:{path:Q,value:q}});this.fInstance.api.setParamValue(this.fDSP,this.fPathTable[Q],q)}getParamValue(Q){return this.fInstance.api.getParamValue(this.fDSP,this.fPathTable[Q])}getMeta(){return this.fJSONDsp}getJSON(){return this.fInstance.json}getDescriptors(){return this.fDescriptor}getUI(){return this.fJSONDsp.ui}},S=class Q{constructor(q,U,X,Y,Z){this.fFreqLabel=[],this.fGateLabel=[],this.fGainLabel=[],this.fKeyLabel=[],this.fVelLabel=[],this.fCurNote=Q.kFreeVoice,this.fNextNote=-1,this.fNextVel=-1,this.fDate=0,this.fLevel=0,this.fRelease=0,this.fDSP=q,this.fAPI=U,this.fAPI.init(this.fDSP,Z),this.extractPaths(X,Y)}static get kActiveVoice(){return 0}static get kFreeVoice(){return-1}static get kReleaseVoice(){return-2}static get kLegatoVoice(){return-3}static get kNoVoice(){return-4}static get VOICE_STOP_LEVEL(){return 0.0005}static midiToFreq(q){return 440*2**((q-69)/12)}static normalizeVelocity(q){return q/127}extractPaths(q,U){q.forEach((X)=>{if(X.endsWith("/gate"))this.fGateLabel.push(U[X]);else if(X.endsWith("/freq"))this.fFreqLabel.push(U[X]);else if(X.endsWith("/key"))this.fKeyLabel.push(U[X]);else if(X.endsWith("/gain"))this.fGainLabel.push(U[X]);else if(X.endsWith("/vel")&&X.endsWith("/velocity"))this.fVelLabel.push(U[X])})}keyOn(q,U,X=!1){if(X)this.fNextNote=q,this.fNextVel=U;else this.fFreqLabel.forEach((Y)=>this.fAPI.setParamValue(this.fDSP,Y,Q.midiToFreq(q))),this.fGateLabel.forEach((Y)=>this.fAPI.setParamValue(this.fDSP,Y,1)),this.fGainLabel.forEach((Y)=>this.fAPI.setParamValue(this.fDSP,Y,Q.normalizeVelocity(U))),this.fKeyLabel.forEach((Y)=>this.fAPI.setParamValue(this.fDSP,Y,q)),this.fVelLabel.forEach((Y)=>this.fAPI.setParamValue(this.fDSP,Y,U)),this.fCurNote=q}keyOff(q=!1){if(this.fGateLabel.forEach((U)=>this.fAPI.setParamValue(this.fDSP,U,0)),q)this.fCurNote=Q.kFreeVoice;else this.fRelease=this.fAPI.getSampleRate(this.fDSP)/2,this.fCurNote=Q.kReleaseVoice}computeLegato(q,U,X,Y){let Z=q/2;this.fGateLabel.forEach((J)=>this.fAPI.setParamValue(this.fDSP,J,0)),this.fAPI.compute(this.fDSP,Z,U,X),this.keyOn(this.fNextNote,this.fNextVel),this.fAPI.compute(this.fDSP,Z,U,Y)}compute(q,U,X){this.fAPI.compute(this.fDSP,q,U,X)}setParamValue(q,U){this.fAPI.setParamValue(this.fDSP,q,U)}getParamValue(q){return this.fAPI.getParamValue(this.fDSP,q)}},e=class Q extends P{constructor(q,U,X,Y,Z){super(X,Y,Z);if(this.fInstance=q,console.log(`sampleSize: ${X} bufferSize: ${Y}`),this.fJSONDsp=JSON.parse(this.fInstance.voiceJSON),this.fJSONEffect=this.fInstance.effectAPI&&this.fInstance.effectJSON?JSON.parse(this.fInstance.effectJSON):null,P.parseUI(this.fJSONDsp.ui,this.fUICallback),this.fJSONEffect)P.parseUI(this.fJSONEffect.ui,this.fUICallback);this.fEndMemory=this.initMemory(),this.fVoiceTable=[];for(let J=0;J<this.fInstance.voices;J++)this.fVoiceTable.push(new S(this.fJSONDsp.size*J,this.fInstance.voiceAPI,this.fInputsItems,this.fPathTable,U));if(this.fInstance.effectAPI)this.fInstance.effectAPI.init(this.fEffect,U);if(this.fSoundfiles.length>0){const J=new m(this.fInstance.memory,this.fEndMemory);for(let K=0;K<this.fInstance.voices;K++)this.initSoundfileMemory(J,this.fJSONDsp.size*K)}}initMemory(){this.fEffect=this.fJSONDsp.size*this.fInstance.voices;const q=this.fEffect+(this.fJSONEffect?this.fJSONEffect.size:0);this.fAudioInputs=q,this.fAudioOutputs=this.fAudioInputs+this.getNumInputs()*this.fPtrSize,this.fAudioMixing=this.fAudioOutputs+this.getNumOutputs()*this.fPtrSize,this.fAudioMixingHalf=this.fAudioMixing+this.getNumOutputs()*this.fPtrSize;const U=this.fAudioMixingHalf+this.getNumOutputs()*this.fPtrSize,X=U+this.getNumInputs()*this.fBufferSize*this.fSampleSize,Y=X+this.getNumOutputs()*this.fBufferSize*this.fSampleSize,Z=Y+this.getNumOutputs()*this.fBufferSize*this.fSampleSize,J=this.fInstance.memory.buffer,K=new Int32Array(J),G=this.fSampleSize===4?new Float32Array(J):new Float64Array(J);if(this.getNumInputs()>0){for(let T=0;T<this.getNumInputs();T++)K[(this.fAudioInputs>>2)+T]=U+this.fBufferSize*this.fSampleSize*T;const R=K.subarray(this.fAudioInputs>>2,this.fAudioInputs+this.getNumInputs()*this.fPtrSize>>2);for(let T=0;T<this.getNumInputs();T++)this.fInChannels[T]=G.subarray(R[T]>>Math.log2(this.fSampleSize),R[T]+this.fBufferSize*this.fSampleSize>>Math.log2(this.fSampleSize))}if(this.getNumOutputs()>0){for(let T=0;T<this.getNumOutputs();T++)K[(this.fAudioOutputs>>2)+T]=X+this.fBufferSize*this.fSampleSize*T,K[(this.fAudioMixing>>2)+T]=Y+this.fBufferSize*this.fSampleSize*T,K[(this.fAudioMixingHalf>>2)+T]=Y+this.fBufferSize*this.fSampleSize*T+this.fBufferSize/2*this.fSampleSize;const R=K.subarray(this.fAudioOutputs>>2,this.fAudioOutputs+this.getNumOutputs()*this.fPtrSize>>2);for(let T=0;T<this.getNumOutputs();T++)this.fOutChannels[T]=G.subarray(R[T]>>Math.log2(this.fSampleSize),R[T]+this.fBufferSize*this.fSampleSize>>Math.log2(this.fSampleSize))}return Z}toString(){return`============== Poly Memory layout ==============
        this.fBufferSize: ${this.fBufferSize}
        this.fJSONDsp.size: ${this.fJSONDsp.size}
        this.fAudioInputs: ${this.fAudioInputs}
        this.fAudioOutputs: ${this.fAudioOutputs}
        this.fAudioMixing: ${this.fAudioMixing}
        this.fAudioMixingHalf: ${this.fAudioMixingHalf}`}allocVoice(q,U){return this.fVoiceTable[q].fDate++,this.fVoiceTable[q].fCurNote=U,q}getPlayingVoice(q){let U=S.kNoVoice,X=Number.MAX_VALUE;for(let Y=0;Y<this.fInstance.voices;Y++)if(this.fVoiceTable[Y].fCurNote===q){if(this.fVoiceTable[Y].fDate<X)X=this.fVoiceTable[Y].fDate,U=Y}return U}getFreeVoice(){for(let Z=0;Z<this.fInstance.voices;Z++)if(this.fVoiceTable[Z].fCurNote===S.kFreeVoice)return this.allocVoice(Z,S.kActiveVoice);let{kNoVoice:q,kNoVoice:U}=S,X=Number.MAX_VALUE,Y=Number.MAX_VALUE;for(let Z=0;Z<this.fInstance.voices;Z++)if(this.fVoiceTable[Z].fCurNote===S.kReleaseVoice){if(this.fVoiceTable[Z].fDate<X)X=this.fVoiceTable[Z].fDate,q=Z}else if(this.fVoiceTable[Z].fDate<Y)Y=this.fVoiceTable[Z].fDate,U=Z;if(X!==Number.MAX_VALUE)return console.log(`Steal release voice : voice_date = ${this.fVoiceTable[q].fDate} voice = ${q}`),this.allocVoice(q,S.kLegatoVoice);if(Y!==Number.MAX_VALUE)return console.log(`Steal playing voice : voice_date = ${this.fVoiceTable[U].fDate} voice = ${U}`),this.allocVoice(U,S.kLegatoVoice);return S.kNoVoice}compute(q,U){if(this.fDestroyed)return!1;if(this.fFirstCall)this.initMemory(),this.fFirstCall=!1;if(!this.fProcessing)return!0;if(this.getNumInputs()>0&&(!q||!q[0]||q[0].length===0))return!0;if(this.getNumOutputs()>0&&(!U||!U[0]||U[0].length===0))return!0;if(q!==void 0)for(let X=0;X<Math.min(this.getNumInputs(),q.length);++X)this.fInChannels[X].set(q[X]);if(this.fComputeHandler)this.fComputeHandler(this.fBufferSize);if(this.fInstance.mixerAPI.clearOutput(this.fBufferSize,this.getNumOutputs(),this.fAudioOutputs),this.fVoiceTable.forEach((X)=>{if(X.fCurNote===S.kLegatoVoice)X.computeLegato(this.fBufferSize,this.fAudioInputs,this.fAudioMixing,this.fAudioMixingHalf),this.fInstance.mixerAPI.fadeOut(this.fBufferSize/2,this.getNumOutputs(),this.fAudioMixing),X.fLevel=this.fInstance.mixerAPI.mixCheckVoice(this.fBufferSize,this.getNumOutputs(),this.fAudioMixing,this.fAudioOutputs);else if(X.fCurNote!==S.kFreeVoice){if(X.compute(this.fBufferSize,this.fAudioInputs,this.fAudioMixing),X.fLevel=this.fInstance.mixerAPI.mixCheckVoice(this.fBufferSize,this.getNumOutputs(),this.fAudioMixing,this.fAudioOutputs),X.fRelease-=this.fBufferSize,X.fCurNote==S.kReleaseVoice&&(X.fLevel<S.VOICE_STOP_LEVEL&&X.fRelease<0))X.fCurNote=S.kFreeVoice}}),this.fInstance.effectAPI)this.fInstance.effectAPI.compute(this.fEffect,this.fBufferSize,this.fAudioOutputs,this.fAudioOutputs);if(this.updateOutputs(),U!==void 0){for(let X=0;X<Math.min(this.getNumOutputs(),U.length);X++){const Y=this.fOutChannels[X];U[X].set(Y)}if(this.fPlotHandler)this.fPlotHandler(U,this.fBufferNum++,this.fCachedEvents.length?this.fCachedEvents:void 0),this.fCachedEvents=[]}return!0}getNumInputs(){return this.fInstance.voiceAPI.getNumInputs(0)}getNumOutputs(){return this.fInstance.voiceAPI.getNumOutputs(0)}static findPath(q,U){if(typeof q!=="object")return!1;else if(q.address)return q.address===U;else{for(let X in q)if(Q.findPath(q[X],U))return!0;return!1}}setParamValue(q,U){if(this.fPlotHandler)this.fCachedEvents.push({type:"param",data:{path:q,value:U}});if(this.fJSONEffect&&Q.findPath(this.fJSONEffect.ui,q)&&this.fInstance.effectAPI)this.fInstance.effectAPI.setParamValue(this.fEffect,this.fPathTable[q],U);else this.fVoiceTable.forEach((X)=>X.setParamValue(this.fPathTable[q],U))}getParamValue(q){if(this.fJSONEffect&&Q.findPath(this.fJSONEffect.ui,q)&&this.fInstance.effectAPI)return this.fInstance.effectAPI.getParamValue(this.fEffect,this.fPathTable[q]);else return this.fVoiceTable[0].getParamValue(this.fPathTable[q])}getMeta(){const q=this.fJSONDsp,U=this.fJSONEffect,X={...q};if(U)X.ui=[{type:"tgroup",label:"Sequencer",items:[{type:"vgroup",label:"Instrument",items:q.ui},{type:"vgroup",label:"Effect",items:U.ui}]}];else X.ui=[{type:"tgroup",label:"Polyphonic",items:[{type:"vgroup",label:"Voices",items:q.ui}]}];return X}getJSON(){return JSON.stringify(this.getMeta())}getUI(){return this.getMeta().ui}getDescriptors(){return this.fDescriptor}midiMessage(q){const U=q[0]>>4,X=q[0]&15,Y=q[1],Z=q[2];if(U===8||U===9&&Z===0)return this.keyOff(X,Y,Z);else if(U===9)return this.keyOn(X,Y,Z);else super.midiMessage(q)}ctrlChange(q,U,X){if(U===123||U===120)this.allNotesOff(!0);else super.ctrlChange(q,U,X)}keyOn(q,U,X){if(this.fPlotHandler)this.fCachedEvents.push({type:"keyOn",data:[q,U,X]});const Y=this.getFreeVoice();this.fVoiceTable[Y].keyOn(U,X,this.fVoiceTable[Y].fCurNote==S.kLegatoVoice)}keyOff(q,U,X){if(this.fPlotHandler)this.fCachedEvents.push({type:"keyOff",data:[q,U,X]});const Y=this.getPlayingVoice(U);if(Y!==S.kNoVoice)this.fVoiceTable[Y].keyOff();else console.log("Playing pitch = %d not found\n",U)}allNotesOff(q=!0){this.fCachedEvents.push({type:"ctrlChange",data:[0,123,0]}),this.fVoiceTable.forEach((U)=>U.keyOff(q))}},x0=class{constructor(Q,q){this.fDSPCode=Q,this.fBufferSize=q,this.fInputs=new Array(this.fDSPCode.getNumInputs()).fill(null).map(()=>new Float32Array(q)),this.fOutputs=new Array(this.fDSPCode.getNumOutputs()).fill(null).map(()=>new Float32Array(q))}getParameterDescriptors(){const Q=[],q=(U)=>{let X=null;const Y=["/gate","/freq","/gain","/key","/vel","/velocity"],Z="address"in U&&!!Y.find((J)=>U.address.endsWith(J));if(this.fDSPCode instanceof n||!Z){if(U.type==="vslider"||U.type==="hslider"||U.type==="nentry")X={name:U.address,defaultValue:U.init||0,minValue:U.min||0,maxValue:U.max||0};else if(U.type==="button"||U.type==="checkbox")X={name:U.address,defaultValue:U.init||0,minValue:0,maxValue:1}}if(X)Q.push(X)};return P.parseUI(this.fDSPCode.getUI(),q),Q}compute(Q,q){return this.fDSPCode.compute(Q,q)}setOutputParamHandler(Q){this.fDSPCode.setOutputParamHandler(Q)}getOutputParamHandler(){return this.fDSPCode.getOutputParamHandler()}setComputeHandler(Q){this.fDSPCode.setComputeHandler(Q)}getComputeHandler(){return this.fDSPCode.getComputeHandler()}setPlotHandler(Q){this.fDSPCode.setPlotHandler(Q)}getPlotHandler(){return this.fDSPCode.getPlotHandler()}getNumInputs(){return this.fDSPCode.getNumInputs()}getNumOutputs(){return this.fDSPCode.getNumOutputs()}metadata(Q){}midiMessage(Q){this.fDSPCode.midiMessage(Q)}ctrlChange(Q,q,U){this.fDSPCode.ctrlChange(Q,q,U)}pitchWheel(Q,q){this.fDSPCode.pitchWheel(Q,q)}setParamValue(Q,q){this.fDSPCode.setParamValue(Q,q)}getParamValue(Q){return this.fDSPCode.getParamValue(Q)}getParams(){return this.fDSPCode.getParams()}getMeta(){return this.fDSPCode.getMeta()}getJSON(){return this.fDSPCode.getJSON()}getDescriptors(){return this.fDSPCode.getDescriptors()}getUI(){return this.fDSPCode.getUI()}start(){this.fDSPCode.start()}stop(){this.fDSPCode.stop()}destroy(){this.fDSPCode.destroy()}get hasAccInput(){return this.fDSPCode.hasAccInput}propagateAcc(Q,q=!1){this.fDSPCode.propagateAcc(Q,q)}get hasGyrInput(){return this.fDSPCode.hasGyrInput}propagateGyr(Q){this.fDSPCode.propagateGyr(Q)}render(Q=[],q=this.fBufferSize,U){let X=0;const Y=new Array(this.fDSPCode.getNumOutputs()).fill(null).map(()=>new Float32Array(q));this.fDSPCode.start();while(X<q){const Z=Math.min(q-X,this.fBufferSize);for(let J=0;J<this.fDSPCode.getNumInputs();J++){let K;if(Q[J])if(Q[J].length<=X)K=new Float32Array(Z);else if(Q[J].length>X+Z)K=Q[J].subarray(X,X+Z);else K=Q[J].subarray(X,Q[J].length);else K=new Float32Array(Z);this.fInputs[J]=K}this.fDSPCode.compute(this.fInputs,this.fOutputs);for(let J=0;J<this.fDSPCode.getNumOutputs();J++){const K=this.fOutputs[J];if(Z<this.fBufferSize)Y[J].set(K.subarray(0,Z),X);else Y[J].set(K,X)}X+=this.fBufferSize,U==null||U(X)}return this.fDSPCode.stop(),Y}},C1=class extends x0{},D1=class extends x0{keyOn(Q,q,U){this.fDSPCode.keyOn(Q,q,U)}keyOff(Q,q,U){this.fDSPCode.keyOff(Q,q,U)}allNotesOff(Q){this.fDSPCode.allNotesOff(Q)}};var z1=class{constructor(Q){this.fModule=Q,this.fCompiler=new Q.libFaustWasm,this.fFileSystem=this.fModule.FS}module(){return this.fModule}fs(){return this.fFileSystem}version(){return this.fCompiler.version()}createDSPFactory(Q,q,U,X){return this.fCompiler.createDSPFactory(Q,q,U,X)}deleteDSPFactory(Q){return this.fCompiler.deleteDSPFactory(Q)}expandDSP(Q,q,U){return this.fCompiler.expandDSP(Q,q,U)}generateAuxFiles(Q,q,U){return this.fCompiler.generateAuxFiles(Q,q,U)}deleteAllDSPFactories(){return this.fCompiler.deleteAllDSPFactories()}getErrorAfterException(){return this.fCompiler.getErrorAfterException()}cleanupAfterException(){return this.fCompiler.cleanupAfterException()}getInfos(Q){return this.fCompiler.getInfos(Q)}toString(){return`LibFaust module: ${this.fModule}, compiler: ${this.fCompiler}`}},y0=z1;var w1=class{static get fallbackPaths(){return[location.href,this.getParentUrl(location.href),location.origin]}static getParentUrl(Q){return Q.substring(0,Q.lastIndexOf("/")+1)}static toAudioData(Q){const{sampleRate:q,numberOfChannels:U}=Q;return{sampleRate:q,audioBuffer:new Array(U).fill(null).map((X,Y)=>Q.getChannelData(Y))}}static findSoundfilesFromMeta(Q){const q={},U=(X)=>{if(X.type==="soundfile")P.splitSoundfileNames(X.url).forEach((Z)=>q[Z]=null)};return P.parseUI(Q.ui,U),q}static async checkFileExists(Q){try{console.log(`"checkFileExists" url: ${Q}`);const q=await fetch(Q);return console.log(`"checkFileExists" response.ok: ${q.ok}`),q.ok}catch(q){return console.error("Fetch error:",q),!1}}static async fetchSoundfile(Q,q){console.log(`Loading sound file from ${Q}`);const U=await fetch(Q);if(!U.ok)throw new Error(`Failed to load sound file from ${Q}: ${U.statusText}`);const X=await U.arrayBuffer(),Y=await q.decodeAudioData(X);return this.toAudioData(Y)}static async loadSoundfile(Q,q,U,X){if(U[Q])return;const Y=[Q,...[...q,...this.fallbackPaths].map((K)=>new URL(Q,K.endsWith("/")?K:`${K}/`).href)],J=(await Promise.all(Y.map((K)=>this.checkFileExists(K)))).findIndex((K)=>!!K);if(J===-1)throw new Error(`Failed to load sound file ${Q}, all check failed.`);U[Q]=await this.fetchSoundfile(Y[J],X)}static async loadSoundfiles(Q,q,U){const X=P.extractUrlsFromMeta(Q),Y=this.findSoundfilesFromMeta(Q);for(let Z in Y){if(q[Z]){Y[Z]=q[Z];continue}try{await this.loadSoundfile(Z,X,Y,U)}catch(J){console.error(J)}}return Y}},o=w1,Z0,J0,v0=class extends(globalThis.AudioWorkletNode||null){constructor(Q,q,U,X={}){const Y=JSON.parse(U.json);super(Q,q,{numberOfInputs:Y.inputs>0?1:0,numberOfOutputs:Y.outputs>0?1:0,channelCount:Math.max(1,Y.inputs),outputChannelCount:[Y.outputs],channelCountMode:"explicit",channelInterpretation:"speakers",processorOptions:X.processorOptions,...X});w0(this,Z0,!1),w0(this,J0,!1),this.handleDeviceMotion=({accelerationIncludingGravity:Z})=>{const J=/Android/i.test(navigator.userAgent);if(!Z)return;const{x:K,y:G,z:R}=Z;this.propagateAcc({x:K,y:G,z:R},J)},this.handleDeviceOrientation=({alpha:Z,beta:J,gamma:K})=>{this.propagateGyr({alpha:Z,beta:J,gamma:K})},this.fJSONDsp=Y,this.fJSON=U.json,this.fOutputHandler=null,this.fComputeHandler=null,this.fPlotHandler=null,this.fDescriptor=[],this.fInputsItems=[],this.fUICallback=(Z)=>{if(Z.type==="vslider"||Z.type==="hslider"||Z.type==="button"||Z.type==="checkbox"||Z.type==="nentry"){if(this.fInputsItems.push(Z.address),this.fDescriptor.push(Z),!Z.meta)return;Z.meta.forEach((J)=>{const{midi:K,acc:G,gyr:R}=J;if(G)_0(this,Z0,!0);if(R)_0(this,J0,!0)})}},P.parseUI(this.fJSONDsp.ui,this.fUICallback),this.port.onmessage=(Z)=>{if(Z.data.type==="param"&&this.fOutputHandler)this.fOutputHandler(Z.data.path,Z.data.value);else if(Z.data.type==="plot"&&this.fPlotHandler)this.fPlotHandler(Z.data.value,Z.data.index,Z.data.events)}}async startSensors(){if(this.hasAccInput)if(window.DeviceMotionEvent)if(typeof window.DeviceMotionEvent.requestPermission==="function")try{const Q=await window.DeviceMotionEvent.requestPermission();if(Q==="granted")window.addEventListener("devicemotion",this.handleDeviceMotion,!0);else if(Q==="denied")throw alert("You have denied access to motion and orientation data. To enable it, go to Settings > Safari > Motion & Orientation Access."),new Error("Unable to access the accelerometer.")}catch(Q){console.error(Q)}else window.addEventListener("devicemotion",this.handleDeviceMotion,!0);else console.log("Cannot set the accelerometer handler.");if(this.hasGyrInput)if(window.DeviceMotionEvent)if(typeof window.DeviceOrientationEvent.requestPermission==="function")try{const Q=await window.DeviceOrientationEvent.requestPermission();if(Q==="granted")window.addEventListener("deviceorientation",this.handleDeviceOrientation,!0);else if(Q==="denied")throw alert("You have denied access to motion and orientation data. To enable it, go to Settings > Safari > Motion & Orientation Access."),new Error("Unable to access the gyroscope.")}catch(Q){console.error(Q)}else window.addEventListener("deviceorientation",this.handleDeviceOrientation,!0);else console.log("Cannot set the gyroscope handler.")}stopSensors(){if(this.hasAccInput)window.removeEventListener("devicemotion",this.handleDeviceMotion,!0);if(this.hasGyrInput)window.removeEventListener("deviceorientation",this.handleDeviceOrientation,!0)}setOutputParamHandler(Q){this.fOutputHandler=Q}getOutputParamHandler(){return this.fOutputHandler}setComputeHandler(Q){this.fComputeHandler=Q}getComputeHandler(){return this.fComputeHandler}setPlotHandler(Q){if(this.fPlotHandler=Q,this.fPlotHandler)this.port.postMessage({type:"setPlotHandler",data:!0});else this.port.postMessage({type:"setPlotHandler",data:!1})}getPlotHandler(){return this.fPlotHandler}setupWamEventHandler(){this.port.postMessage({type:"setupWamEventHandler"})}getNumInputs(){return this.fJSONDsp.inputs}getNumOutputs(){return this.fJSONDsp.outputs}compute(Q,q){return!1}metadata(Q){if(this.fJSONDsp.meta)this.fJSONDsp.meta.forEach((q)=>Q(Object.keys(q)[0],q[Object.keys(q)[0]]))}midiMessage(Q){const q=Q[0]>>4,U=Q[0]&15,X=Q[1],Y=Q[2];if(q===11)this.ctrlChange(U,X,Y);else if(q===14)this.pitchWheel(U,Y*128+X);else this.port.postMessage({type:"midi",data:Q})}ctrlChange(Q,q,U){const X={type:"ctrlChange",data:[Q,q,U]};this.port.postMessage(X)}pitchWheel(Q,q){const U={type:"pitchWheel",data:[Q,q]};this.port.postMessage(U)}get hasAccInput(){return z0(this,Z0)}propagateAcc(Q,q=!1){if(!Q)return;const U={type:"acc",data:Q,invert:q};this.port.postMessage(U)}get hasGyrInput(){return z0(this,J0)}propagateGyr(Q){if(!Q)return;const q={type:"gyr",data:Q};this.port.postMessage(q)}setParamValue(Q,q){const U={type:"param",data:{path:Q,value:q}};this.port.postMessage(U);const X=this.parameters.get(Q);if(X)X.setValueAtTime(q,this.context.currentTime)}getParamValue(Q){const q=this.parameters.get(Q);return q?q.value:0}getParams(){return this.fInputsItems}getMeta(){return this.fJSONDsp}getJSON(){return JSON.stringify(this.getMeta())}getUI(){return this.fJSONDsp.ui}getDescriptors(){return this.fDescriptor}start(){this.port.postMessage({type:"start"})}stop(){this.port.postMessage({type:"stop"})}destroy(){this.port.postMessage({type:"destroy"}),this.port.close()}};Z0=new WeakMap;J0=new WeakMap;var P0=class extends v0{constructor(Q,q){super(Q,q.processorOptions.name,q.processorOptions.factory,q);this.onprocessorerror=(U)=>{throw U}}},_1=class extends v0{constructor(Q,q){super(Q,q.processorOptions.name,q.processorOptions.voiceFactory,q);if(this.onprocessorerror=(U)=>{throw U},this.fJSONEffect=q.processorOptions.effectFactory?JSON.parse(q.processorOptions.effectFactory.json):null,this.fJSONEffect)P.parseUI(this.fJSONEffect.ui,this.fUICallback)}keyOn(Q,q,U){const X={type:"keyOn",data:[Q,q,U]};this.port.postMessage(X)}keyOff(Q,q,U){const X={type:"keyOff",data:[Q,q,U]};this.port.postMessage(X)}allNotesOff(Q){const q={type:"ctrlChange",data:[0,123,0]};this.port.postMessage(q)}getMeta(){const Q=this.fJSONDsp,q=this.fJSONEffect,U={...Q};if(q)U.ui=[{type:"tgroup",label:"Sequencer",items:[{type:"vgroup",label:"Instrument",items:Q.ui},{type:"vgroup",label:"Effect",items:q.ui}]}];else U.ui=[{type:"tgroup",label:"Polyphonic",items:[{type:"vgroup",label:"Voices",items:Q.ui}]}];return U}getJSON(){return JSON.stringify(this.getMeta())}getUI(){return this.getMeta().ui}},p0=class extends(globalThis.ScriptProcessorNode||null){constructor(){super(...arguments);this.handleDeviceMotion=void 0,this.handleDeviceOrientation=void 0}init(Q){this.fDSPCode=Q,this.fInputs=new Array(this.fDSPCode.getNumInputs()),this.fOutputs=new Array(this.fDSPCode.getNumOutputs()),this.handleDeviceMotion=({accelerationIncludingGravity:q})=>{const U=/Android/i.test(navigator.userAgent);if(!q)return;const{x:X,y:Y,z:Z}=q;this.propagateAcc({x:X,y:Y,z:Z},U)},this.handleDeviceOrientation=({alpha:q,beta:U,gamma:X})=>{this.propagateGyr({alpha:q,beta:U,gamma:X})},this.onaudioprocess=(q)=>{for(let U=0;U<this.fDSPCode.getNumInputs();U++)this.fInputs[U]=q.inputBuffer.getChannelData(U);for(let U=0;U<this.fDSPCode.getNumOutputs();U++)this.fOutputs[U]=q.outputBuffer.getChannelData(U);return this.fDSPCode.compute(this.fInputs,this.fOutputs)},this.start()}async startSensors(){if(this.hasAccInput)if(window.DeviceMotionEvent)if(typeof window.DeviceMotionEvent.requestPermission==="function")try{const Q=await window.DeviceMotionEvent.requestPermission();if(Q==="granted")window.addEventListener("devicemotion",this.handleDeviceMotion,!0);else if(Q==="denied")throw alert("You have denied access to motion and orientation data. To enable it, go to Settings > Safari > Motion & Orientation Access."),new Error("Unable to access the accelerometer.")}catch(Q){console.error(Q)}else window.addEventListener("devicemotion",this.handleDeviceMotion,!0);else console.log("Cannot set the accelerometer handler.");if(this.hasGyrInput)if(window.DeviceMotionEvent)if(typeof window.DeviceOrientationEvent.requestPermission==="function")try{const Q=await window.DeviceOrientationEvent.requestPermission();if(Q==="granted")window.addEventListener("deviceorientation",this.handleDeviceOrientation,!0);else if(Q==="denied")throw alert("You have denied access to motion and orientation data. To enable it, go to Settings > Safari > Motion & Orientation Access."),new Error("Unable to access the gyroscope.")}catch(Q){console.error(Q)}else window.addEventListener("deviceorientation",this.handleDeviceOrientation,!0);else console.log("Cannot set the gyroscope handler.")}stopSensors(){if(this.hasAccInput)window.removeEventListener("devicemotion",this.handleDeviceMotion,!0);if(this.hasGyrInput)window.removeEventListener("deviceorientation",this.handleDeviceOrientation,!0)}compute(Q,q){return this.fDSPCode.compute(Q,q)}setOutputParamHandler(Q){this.fDSPCode.setOutputParamHandler(Q)}getOutputParamHandler(){return this.fDSPCode.getOutputParamHandler()}setComputeHandler(Q){this.fDSPCode.setComputeHandler(Q)}getComputeHandler(){return this.fDSPCode.getComputeHandler()}setPlotHandler(Q){this.fDSPCode.setPlotHandler(Q)}getPlotHandler(){return this.fDSPCode.getPlotHandler()}getNumInputs(){return this.fDSPCode.getNumInputs()}getNumOutputs(){return this.fDSPCode.getNumOutputs()}metadata(Q){}midiMessage(Q){this.fDSPCode.midiMessage(Q)}ctrlChange(Q,q,U){this.fDSPCode.ctrlChange(Q,q,U)}pitchWheel(Q,q){this.fDSPCode.pitchWheel(Q,q)}setParamValue(Q,q){this.fDSPCode.setParamValue(Q,q)}getParamValue(Q){return this.fDSPCode.getParamValue(Q)}getParams(){return this.fDSPCode.getParams()}getMeta(){return this.fDSPCode.getMeta()}getJSON(){return this.fDSPCode.getJSON()}getDescriptors(){return this.fDSPCode.getDescriptors()}getUI(){return this.fDSPCode.getUI()}start(){this.fDSPCode.start()}stop(){this.fDSPCode.stop()}destroy(){this.fDSPCode.destroy()}get hasAccInput(){return this.fDSPCode.hasAccInput}propagateAcc(Q,q=!1){this.fDSPCode.propagateAcc(Q,q)}get hasGyrInput(){return this.fDSPCode.hasGyrInput}propagateGyr(Q){this.fDSPCode.propagateGyr(Q)}},P1=class extends p0{},S1=class extends p0{keyOn(Q,q,U){this.fDSPCode.keyOn(Q,q,U)}keyOff(Q,q,U){this.fDSPCode.keyOff(Q,q,U)}allNotesOff(Q){this.fDSPCode.allNotesOff(Q)}},d0=class Q{constructor(){this.factory=null}async compile(q,U,X,Y){if(this.factory=await q.createMonoDSPFactory(U,X,Y),this.factory)return this.name=U,this;else return null}addSoundfiles(q){if(!this.factory)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");for(let U in q)this.factory.soundfiles[U]=q[U]}getSoundfileList(){if(!this.factory)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");const q=JSON.parse(this.factory.json),U=o.findSoundfilesFromMeta(q);return Object.keys(U)}async createNode(q,U=this.name,X=this.factory,Y=!1,Z=1024,J=(X==null?void 0:X.shaKey)||U,K={}){var G,R;if(!X)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");const T=JSON.parse(X.json),k=T.compile_options.match("-double")?8:4;if(X.soundfiles=await o.loadSoundfiles(T,X.soundfiles||{},q),Y){const W=await d.createAsyncMonoDSPInstance(X),L=new n(W,q.sampleRate,k,Z,X.soundfiles),D=q.createScriptProcessor(Z,L.getNumInputs(),L.getNumOutputs());return Object.setPrototypeOf(D,P1.prototype),D.init(L),D}else{if(!Q.gWorkletProcessors.has(q))Q.gWorkletProcessors.set(q,new Set);if(!((G=Q.gWorkletProcessors.get(q))==null?void 0:G.has(J)))try{const L=`
// DSP name and JSON string for DSP are generated
const faustData = ${JSON.stringify({processorName:J,dspName:U,dspMeta:T,poly:!1})};
// Implementation needed classes of functions
var ${s.name} = ${s.toString()}
var FaustDspInstance = ${s.name};
var ${P.name} = ${P.toString()}
var FaustBaseWebAudioDsp = ${P.name};
var ${n.name} = ${n.toString()}
var FaustMonoWebAudioDsp = ${n.name};
var ${d.name} = ${d.toString()}
var FaustWasmInstantiator = ${d.name};
var ${f.name} = ${f.toString()}
var Soundfile = ${f.name};
var ${m.name} = ${m.toString()}
var WasmAllocator = ${m.name};
var ${l.name} = ${l.toString()}
var FaustSensors = ${l.name};
// Put them in dependencies
const dependencies = {
    FaustBaseWebAudioDsp,
    FaustMonoWebAudioDsp,
    FaustWasmInstantiator
};
// Generate the actual AudioWorkletProcessor code
(${K0.toString()})(dependencies, faustData);
`,D=URL.createObjectURL(new Blob([L],{type:"text/javascript"}));await q.audioWorklet.addModule(D),(R=Q.gWorkletProcessors.get(q))==null||R.add(J)}catch(L){throw L}return new P0(q,{processorOptions:{name:J,factory:X,sampleSize:k,...K}})}}async createFFTNode(q,U,X=this.name,Y=this.factory,Z={},J=(Y==null?void 0:Y.shaKey)?`${Y.shaKey}_fft`:X,K={}){var G,R;if(!Y)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");const T=JSON.parse(Y.json),k=T.compile_options.match("-double")?8:4;if(Y.soundfiles=await o.loadSoundfiles(T,Y.soundfiles||{},q),!Q.gWorkletProcessors.has(q))Q.gWorkletProcessors.set(q,new Set);if(!((G=Q.gWorkletProcessors.get(q))==null?void 0:G.has(J)))try{const L=`
// DSP name and JSON string for DSP are generated
const faustData = ${JSON.stringify({processorName:J,dspName:X,dspMeta:T,fftOptions:Z})};
// Implementation needed classes of functions
var ${s.name} = ${s.toString()}
var FaustDspInstance = ${s.name};
var ${P.name} = ${P.toString()}
var FaustBaseWebAudioDsp = ${P.name};
var ${n.name} = ${n.toString()}
var FaustMonoWebAudioDsp = ${n.name};
var ${d.name} = ${d.toString()}
var FaustWasmInstantiator = ${d.name};
var ${f.name} = ${f.toString()}
var Soundfile = ${f.name};
var ${m.name} = ${m.toString()}
var WasmAllocator = ${m.name};
var ${l.name} = ${l.toString()}
var FaustSensors = ${l.name};
var FFTUtils = ${U.toString()}
// Put them in dependencies
const dependencies = {
    FaustBaseWebAudioDsp,
    FaustMonoWebAudioDsp,
    FaustWasmInstantiator,
    FFTUtils
};
// Generate the actual AudioWorkletProcessor code
(${R1.toString()})(dependencies, faustData);
`,D=URL.createObjectURL(new Blob([L],{type:"text/javascript"}));await q.audioWorklet.addModule(D),(R=Q.gWorkletProcessors.get(q))==null||R.add(J)}catch(L){throw L}const W=new P0(q,{channelCount:Math.max(1,Math.ceil(T.inputs/3)),outputChannelCount:[Math.ceil(T.outputs/2)],processorOptions:{name:J,factory:Y,sampleSize:k,...K}});if(Z.fftSize){const L=W.parameters.get("fftSize");if(L)L.value=Z.fftSize}if(Z.fftOverlap){const L=W.parameters.get("fftOverlap");if(L)L.value=Z.fftOverlap}if(typeof Z.defaultWindowFunction==="number"){const L=W.parameters.get("windowFunction");if(L)L.value=Z.defaultWindowFunction+1}if(typeof Z.noIFFT==="boolean"){const L=W.parameters.get("noIFFT");if(L)L.value=+Z.noIFFT}return W}async createAudioWorkletProcessor(q=this.name,U=this.factory,X=(U==null?void 0:U.shaKey)||q){if(!U)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");const Y=JSON.parse(U.json),Z={FaustBaseWebAudioDsp:P,FaustMonoWebAudioDsp:n,FaustWasmInstantiator:d,FaustPolyWebAudioDsp:void 0,FaustWebAudioDspVoice:void 0};try{return K0(Z,{processorName:X,dspName:q,dspMeta:Y,poly:!1})}catch(J){throw J}}async createOfflineProcessor(q,U,X=this.factory,Y){if(!X)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");const Z=JSON.parse(X.json),J=await d.createAsyncMonoDSPInstance(X),K=Z.compile_options.match("-double")?8:4;if(Y)X.soundfiles=await o.loadSoundfiles(Z,X.soundfiles||{},Y);const G=new n(J,q,K,U,X.soundfiles);return new C1(G,U)}getMeta(){return JSON.parse(this.factory.json)}getJSON(){return JSON.stringify(this.getMeta())}getUI(){return this.getMeta().ui}};d0.gWorkletProcessors=new Map;var l0=d0,g1=class Q{constructor(){this.voiceFactory=null,this.effectFactory=null}async compile(q,U,X,Y,Z=`dsp_code = environment{
                ${X}
            };
            process = dsp_code.effect;`){try{if(this.effectFactory=await q.createPolyDSPFactory(U,Z,Y),this.effectFactory){const J=JSON.parse(this.effectFactory.json),K=`// Voice output is forced to 2, when DSP is stereo or effect has 2 ins or 2 outs,
// so that the effect can process the 2 channels of the voice
adaptOut(1,1,1) = _;
adaptOut(1,1,2) = _ <: _,0;  // The left channel only is kept
adaptOut(1,2,1) = _ <: _,_;
adaptOut(1,2,2) = _ <: _,_;
adaptOut(2,1,1) = _,_;
adaptOut(2,1,2) = _,_;
adaptOut(2,2,1) = _,_;
adaptOut(2,2,2) = _,_;
adaptor(F) = adaptOut(outputs(F),${J.inputs},${J.outputs});
dsp_code = environment{
    ${X}
};
process = dsp_code.process : adaptor(dsp_code.process);
`,G=`// Inputs
adaptIn(1,1,1) = _;
adaptIn(1,1,2) = _,_ :> _;  
adaptIn(1,2,1) = _,_;
adaptIn(1,2,2) = _,_;
adaptIn(2,1,1) = _,_ :> _;
adaptIn(2,1,2) = _,_ :> _;
adaptIn(2,2,1) = _,_;
adaptIn(2,2,2) = _,_;
// Outputs
adaptOut(1,1) = _ <: _,0;   // The left channel only is kept
adaptOut(1,2) = _,_;
adaptOut(2,1) = _ <: _,0;   // The left channel only is kept
adaptOut(2,2) = _,_;
adaptorIns(F) = adaptIn(outputs(F),${J.inputs},${J.outputs});
adaptorOuts = adaptOut(${J.inputs},${J.outputs});
dsp_code = environment{
    ${X}
};
process = adaptorIns(dsp_code.process) : dsp_code.effect : adaptorOuts;
`;this.voiceFactory=await q.createPolyDSPFactory(U,K,Y);try{this.effectFactory=await q.createPolyDSPFactory(U,G,Y+" -inpl")}catch(R){console.warn(R)}}}catch(J){console.warn(J),this.voiceFactory=await q.createPolyDSPFactory(U,X,Y)}if(this.voiceFactory){this.name=U;const K=JSON.parse(this.voiceFactory.json).compile_options.match("-double"),{mixerBuffer:G,mixerModule:R}=await q.getAsyncInternalMixerModule(!!K);return this.mixerBuffer=G,this.mixerModule=R,this}else return null}addSoundfiles(q){if(!this.voiceFactory)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");for(let U in q)this.voiceFactory.soundfiles[U]=q[U]}getSoundfileList(){if(!this.voiceFactory)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");const q=JSON.parse(this.voiceFactory.json),U=o.findSoundfilesFromMeta(q);if(!this.effectFactory)return Object.keys(U);const X=JSON.parse(this.effectFactory.json),Y=o.findSoundfilesFromMeta(X);return Object.keys({...Y,...U})}async createNode(q,U,X=this.name,Y=this.voiceFactory,Z=this.mixerModule,J=this.effectFactory,K=!1,G=1024,R=((Y==null?void 0:Y.shaKey)||"")+((J==null?void 0:J.shaKey)||"")||`${X}_poly`,T={}){var k,W;if(!Y)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");const L=JSON.parse(Y.json),D=J?JSON.parse(J.json):void 0,F=L.compile_options.match("-double")?8:4;if(Y.soundfiles=await o.loadSoundfiles(L,Y.soundfiles||{},q),J)J.soundfiles=await o.loadSoundfiles(D,J.soundfiles||{},q);if(K){const z=await d.createAsyncPolyDSPInstance(Y,Z,U,J||void 0),g={...J==null?void 0:J.soundfiles,...Y.soundfiles},V=new e(z,q.sampleRate,F,G,g),B=q.createScriptProcessor(G,V.getNumInputs(),V.getNumOutputs());return Object.setPrototypeOf(B,S1.prototype),B.init(V),B}else{if(!Q.gWorkletProcessors.has(q))Q.gWorkletProcessors.set(q,new Set);if(!((k=Q.gWorkletProcessors.get(q))==null?void 0:k.has(R)))try{const g=`
// DSP name and JSON string for DSP are generated
const faustData = ${JSON.stringify({processorName:R,dspName:X,dspMeta:L,poly:!0,effectMeta:D})};
// Implementation needed classes of functions
var ${s.name} = ${s.toString()}
var FaustDspInstance = ${s.name};
var ${P.name} = ${P.toString()}
var FaustBaseWebAudioDsp = ${P.name};
var ${e.name} = ${e.toString()}
var FaustPolyWebAudioDsp = ${e.name};
var ${S.name} = ${S.toString()}
var FaustWebAudioDspVoice = ${S.name};
var ${d.name} = ${d.toString()}
var FaustWasmInstantiator = ${d.name};
var ${f.name} = ${f.toString()}
var Soundfile = ${f.name};
var ${m.name} = ${m.toString()}
var WasmAllocator = ${m.name};
var ${l.name} = ${l.toString()}
var FaustSensors = ${l.name};
// Put them in dependencies
const dependencies = {
    FaustBaseWebAudioDsp,
    FaustPolyWebAudioDsp,
    FaustWasmInstantiator
};
// Generate the actual AudioWorkletProcessor code
(${K0.toString()})(dependencies, faustData);
`,V=URL.createObjectURL(new Blob([g],{type:"text/javascript"}));await q.audioWorklet.addModule(V),(W=Q.gWorkletProcessors.get(q))==null||W.add(R)}catch(g){throw g}return new _1(q,{processorOptions:{name:R,voiceFactory:Y,mixerModule:Z,voices:U,sampleSize:F,effectFactory:J||void 0,...T}})}}async createAudioWorkletProcessor(q=this.name,U=this.voiceFactory,X=this.effectFactory,Y=((U==null?void 0:U.shaKey)||"")+((X==null?void 0:X.shaKey)||"")||`${q}_poly`){if(!U)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");const Z=JSON.parse(U.json),J=X?JSON.parse(X.json):void 0,K=Z.compile_options.match("-double")?8:4;try{return K0({FaustBaseWebAudioDsp:P,FaustMonoWebAudioDsp:void 0,FaustWasmInstantiator:d,FaustPolyWebAudioDsp:e,FaustWebAudioDspVoice:S},{processorName:Y,dspName:q,dspMeta:Z,poly:!0,effectMeta:J})}catch(G){throw G}}async createOfflineProcessor(q,U,X,Y=this.voiceFactory,Z=this.mixerModule,J=this.effectFactory,K){if(!Y)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");const G=JSON.parse(Y.json),R=J?JSON.parse(J.json):void 0,T=await d.createAsyncPolyDSPInstance(Y,Z,X,J||void 0),k=G.compile_options.match("-double")?8:4;if(K){if(Y.soundfiles=await o.loadSoundfiles(G,Y.soundfiles||{},K),J)J.soundfiles=await o.loadSoundfiles(R,J.soundfiles||{},K)}const W={...J==null?void 0:J.soundfiles,...Y.soundfiles},L=new e(T,q,k,U,W);return new D1(L,U)}getMeta(){const q=this.voiceFactory?JSON.parse(this.voiceFactory.json):null,U=this.effectFactory?JSON.parse(this.effectFactory.json):null,X={...q};if(U)X.ui=[{type:"tgroup",label:"Sequencer",items:[{type:"vgroup",label:"Instrument",items:q.ui},{type:"vgroup",label:"Effect",items:U.ui}]}];else X.ui=[{type:"tgroup",label:"Polyphonic",items:[{type:"vgroup",label:"Voices",items:q.ui}]}];return X}getJSON(){return JSON.stringify(this.getMeta())}getUI(){return this.getMeta().ui}};g1.gWorkletProcessors=new Map;var f0=globalThis;f0.window=globalThis;self.onmessage=async function(Q){try{const q=Q.data,U=q.content,X=q.target,Y=q.faustModuleUrl,Z=q.filename,J=await g0(Y),K=new y0(J);f0.libFaust=K;const G=new F0(K),R=Z.split("/").at(-1).split(".")[0].trim();if(X=="cmajor"){if(!G.generateAuxFiles(R,U,"-lang cmajor-hybrid -cn "+R+" -o foo.cmajor"))throw new Error("Ooops");self.postMessage(G.fs().readFile("foo.cmajor",{encoding:"utf8"}))}else{const T=new l0;await T.compile(G,R,U,"-lang wasm-i -json -ct 1 -es 1 -mcd 16 -mdd 1024 -mdy 33 -single -ftz 2");const k=T.factory.code,W=JSON.parse(T.factory.json),L=btoa(String.fromCharCode(...k));self.postMessage({wasm:L,json:W})}}catch(q){self.postMessage({error:q.message})}};

//# debugId=C6AE829DA67FEA1464756E2164756E21
//# sourceMappingURL=faust.worker.js.map
